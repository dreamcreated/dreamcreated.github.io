<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dream Creator&#39;s blog</title>
  
  <subtitle>一个爱做梦的人在这里自说自话</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lida.site/"/>
  <updated>2019-07-30T08:15:18.239Z</updated>
  <id>http://lida.site/</id>
  
  <author>
    <name>David Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++11的右值引用和move语义</title>
    <link href="http://lida.site/2019/07/30/C-11%E7%9A%84%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8Cmove%E8%AF%AD%E4%B9%89/"/>
    <id>http://lida.site/2019/07/30/C-11的右值引用和move语义/</id>
    <published>2019-07-30T06:13:46.000Z</published>
    <updated>2019-07-30T08:15:18.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我理解的右值引用"><a href="#我理解的右值引用" class="headerlink" title="我理解的右值引用"></a>我理解的右值引用</h1><p>右值，顾名思义，就是 “=” 号右边的值，通常是个常量或者临时变量，比如代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> foo = <span class="number">123</span>; <span class="comment">//foo是lvalue， 123是rvalue</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> left + right;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> result = plus(<span class="number">1</span>, <span class="number">2</span>);   <span class="comment">//result是lvalue, plus函数的计算结果是一个rvalue</span></div></pre></td></tr></table></figure></p><h1 id="右值引用提供了什么能力"><a href="#右值引用提供了什么能力" class="headerlink" title="右值引用提供了什么能力"></a>右值引用提供了什么能力</h1><p>右值引用提供了对右值进行操作的能力,以此来达到对临时变量进行复用，避免无意义的临时变量深拷贝。<br>举一个例子，在没有右值引用的年代，我们用std::string时常常会想起大师的教导，不要写出下面的代码： “std::string(“aaa”) + std::string(“bbb”) + std::string(“ccc”) + std::string(“ddd”)”<br>这种写法是为人所不齿的，因为会产生无数个临时变量。<br>但是有了右值引用之后， “std::string(“aaa”) + std::string(“bbb”)” 是两个右值相加，那么可以把right 累加到 left上，返回left， left又是一个右值， 继续和后面的string做运算，类似于下面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> str = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"aaa"</span>);</div><div class="line">str += <span class="string">"bbb"</span>;</div><div class="line">str += <span class="string">"ccc"</span>;</div><div class="line">str += <span class="string">"ddd"</span>;</div></pre></td></tr></table></figure></p><h1 id="右值引用配合unique-ptr和pImpl写法"><a href="#右值引用配合unique-ptr和pImpl写法" class="headerlink" title="右值引用配合unique_ptr和pImpl写法"></a>右值引用配合unique_ptr和pImpl写法</h1><p>核心思想是，把占用内存空间大的对象封装到一个impl嵌套类里面，用unique_ptr进行维护，unique_ptr有独占语义，并且如果不自定义销毁函数的话，他所占用的空间和一个裸指针无异，享受方便封装的同时不带来任何的额外负担。<br>所有对象都封装到impl里面的另一个好处是，move语义时可以很方便的实现，只需要move pImpl本身即可。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">g_getObjectId</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> seed = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> seed++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">g_getObjectId2</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> seed = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> seed++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Impl</span> &#123;</span></div><div class="line">        <span class="keyword">int</span> m_objId;</div><div class="line">        Impl() &#123;</div><div class="line">            m_objId = g_getObjectId();</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Widget::Impl "</span> &lt;&lt; m_objId &lt;&lt; <span class="string">" constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        ~Impl() &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Widget::Impl "</span> &lt;&lt; m_objId &lt;&lt; <span class="string">" destructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Widget(Widget&amp;&amp; w) : m_pImpl(<span class="built_in">std</span>::move(w.m_pImpl)), m_selfObjectId(g_getObjectId2()) &#123;   <span class="comment">//右值构造函数</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Widget "</span> &lt;&lt; m_selfObjectId &lt;&lt; <span class="string">" constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Widget() : m_pImpl(<span class="keyword">new</span> Impl()), m_selfObjectId(g_getObjectId2()) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Widget "</span> &lt;&lt; m_selfObjectId &lt;&lt; <span class="string">" constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ~Widget() &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Widget "</span> &lt;&lt; m_selfObjectId &lt;&lt; <span class="string">" destructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getObjectId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> m_pImpl-&gt;m_objId;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Impl&gt; m_pImpl;</div><div class="line">    <span class="keyword">int</span> m_selfObjectId;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Widget w)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo widget for object "</span> &lt;&lt; w.getObjectId() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">const</span> Widget&amp; w)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo widget for const reference"</span> &lt;&lt; w.getObjectId() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;   <span class="comment">//模拟工厂</span></div><div class="line">    Widget w;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(w);   <span class="comment">//w以右值返回，会构造一个新的Widget，但是因为右值有右值构造函数，成本很低</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Widget <span class="title">makeWidgetWithoutMove</span><span class="params">()</span> </span>&#123;   <span class="comment">//模拟工厂</span></div><div class="line">    Widget w;</div><div class="line">    <span class="keyword">return</span> w;   <span class="comment">//利用编译器的RVO（返回值优化）,可能不会有新的Widget被构造</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Widget <span class="title">makeWidgetWithoutMove2</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    Widget a, b;</div><div class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#123;</div><div class="line">        Widget w(makeWidget());</div><div class="line">        foo(<span class="built_in">std</span>::move(w));   <span class="comment">//move语义，表示w下面不再使用</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------------------------------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#123;</div><div class="line">        Widget w(makeWidgetWithoutMove());</div><div class="line">        foo(<span class="built_in">std</span>::move(w));   <span class="comment">//move语义，表示w下面不再使用</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------------------------------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#123;</div><div class="line">        Widget w(makeWidgetWithoutMove2(0));</div><div class="line">        foo(<span class="built_in">std</span>::move(w));   <span class="comment">//move语义，表示w下面不再使用</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------------------------------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#123;</div><div class="line">        Widget w2(makeWidget());</div><div class="line">        foo2(<span class="built_in">std</span>::move(w2));<span class="comment">//move语义，表示w2下面不再使用</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------------------------------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#123;</div><div class="line">        Widget w3(makeWidget());</div><div class="line">        foo2(w3);   <span class="comment">//直接传递ｗ</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>依赖unique_ptr的独占语义，只需要在Widget的右值构造函数中把右值的m_pImpl作为参数给新的Widget的m_pImpl构造即可，unique_ptr会把右值的指针设置为空，以此来保证独占性。右值销毁时，什么都不会做，其指向的m_pImpl内存顺利让渡到新的Widget</p><p>下面是程序的输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">Widget::Impl 0 constructed</div><div class="line">Widget 0 constructed</div><div class="line">Widget 1 constructed</div><div class="line">Widget 0 destructed</div><div class="line">Widget 2 constructed</div><div class="line">foo widget for object 0</div><div class="line">Widget 2 destructed</div><div class="line">Widget::Impl 0 destructed</div><div class="line">Widget 1 destructed</div><div class="line">--------------------------------------------------</div><div class="line">Widget::Impl 1 constructed</div><div class="line">Widget 3 constructed</div><div class="line">Widget 4 constructed</div><div class="line">foo widget for object 1</div><div class="line">Widget 4 destructed</div><div class="line">Widget::Impl 1 destructed</div><div class="line">Widget 3 destructed</div><div class="line">--------------------------------------------------</div><div class="line">Widget::Impl 2 constructed</div><div class="line">Widget 5 constructed</div><div class="line">Widget::Impl 3 constructed</div><div class="line">Widget 6 constructed</div><div class="line">Widget 7 constructed</div><div class="line">Widget 6 destructed</div><div class="line">Widget::Impl 3 destructed</div><div class="line">Widget 5 destructed</div><div class="line">Widget 8 constructed</div><div class="line">foo widget for object 2</div><div class="line">Widget 8 destructed</div><div class="line">Widget::Impl 2 destructed</div><div class="line">Widget 7 destructed</div><div class="line">--------------------------------------------------</div><div class="line">Widget::Impl 4 constructed</div><div class="line">Widget 9 constructed</div><div class="line">Widget 10 constructed</div><div class="line">Widget 9 destructed</div><div class="line">foo widget for const reference4</div><div class="line">Widget 10 destructed</div><div class="line">Widget::Impl 4 destructed</div><div class="line">--------------------------------------------------</div><div class="line">Widget::Impl 5 constructed</div><div class="line">Widget 11 constructed</div><div class="line">Widget 12 constructed</div><div class="line">Widget 11 destructed</div><div class="line">foo widget for const reference5</div><div class="line">Widget 12 destructed</div><div class="line">Widget::Impl 5 destructed</div></pre></td></tr></table></figure></p><p>可以看到4次测试，真正的内存块Impl都是只构造了一次。</p><h1 id="move到底做了啥"><a href="#move到底做了啥" class="headerlink" title="move到底做了啥"></a>move到底做了啥</h1><p>根据 《modern effective c++》 中的描述，move啥也没做，只是把参数做了一个强制右值转换，返回就完了。那么 unique_ptr为何move之后，老的值就变成null了呢。<br>写出上面的测试代码后，我理解了这个问题，其实靠的不是move，而是类的右值构造函数，大概可以模拟一下unique_ptr的代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span>&lt;T&gt;&amp;&amp; rv) &#123;</div><div class="line">        m_pRaw = rv.m_pRaw;</div><div class="line">        rv.m_pRaw = <span class="literal">nullptr</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    T* m_pRaw;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>根据上面的代码，当写出auto newptr = std::move(oldptr)时，oldptr作为一个右值引用被传入newptr的构造函数，然后其原始指针的地址被修改为null了。</p><h1 id="RVO（返回值优化）和右值引用"><a href="#RVO（返回值优化）和右值引用" class="headerlink" title="RVO（返回值优化）和右值引用"></a>RVO（返回值优化）和右值引用</h1><p>第二次测试中，我调用了makeWidgetWithoutMove作为工厂函数，从输出来看，他是构造Widget次数最少的一种方法，这种性能的提升得益于编译器的RVO（返回值优化）策略，但是这个策略比较复杂，比如如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">Widget <span class="title">makeWidgetWithoutMove</span><span class="params">()</span> </span>&#123;   <span class="comment">//模拟工厂</span></div><div class="line">    Widget w;</div><div class="line">    <span class="keyword">return</span> w;   <span class="comment">//利用编译器的RVO（返回值优化）,可能不会有新的Widget被构造</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Widget w(makeWidgetWithoutMove());</div><div class="line">foo(<span class="built_in">std</span>::move(w));   <span class="comment">//move语义，表示w下面不再使用</span></div></pre></td></tr></table></figure></p><p>在编译器经过优化后，会生成如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeWidgetWithoutMove</span><span class="params">(Widget &amp;_result)</span> </span>&#123;   <span class="comment">//模拟工厂</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Widget w;</div><div class="line">makeWidgetWithoutMove(w);</div><div class="line">foo(<span class="built_in">std</span>::move(w));   <span class="comment">//move语义，表示w下面不再使用</span></div></pre></td></tr></table></figure></p><p>这种在函数开头就定义一个Widget实例，在函数结尾返回的例子，通常可以被RVO，但是稍微复杂一点，比如需要根据不同的条件return不同的local var时，RVO就不一定奏效了，如下面的代码所示<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">Widget <span class="title">makeWidgetWithoutMove2</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    Widget a, b;</div><div class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Widget w(makeWidgetWithoutMove2(0));</div><div class="line">foo(<span class="built_in">std</span>::move(w));</div></pre></td></tr></table></figure></p><p>本质上来讲，makeWidgetWithoutMove2 函数内，通过一个变量判断返回哪一个local var，那么编译器就无法确定要用&amp;_result 代替哪一个变量，优化就无从谈起。<br>所以，除了RVO以外，在一些复杂的场景，我们还是需要右值引用来为我们解决函数返回值的性能问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>纸上得来终觉浅，绝知此事要躬行。右值引用看过好多次了，每次都囫囵吞枣，希望这次代码练习和写作可以把它牢牢掌握。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>C++的返回值优化以及右值拷贝 <a href="https://sq.163yun.com/blog/article/170332301127245824" target="_blank" rel="external">https://sq.163yun.com/blog/article/170332301127245824</a></li><li>一次性搞定右值，右值引用（&amp;&amp;），和move语义 <a href="https://juejin.im/post/59c3932d6fb9a00a4b0c4f5b" target="_blank" rel="external">https://juejin.im/post/59c3932d6fb9a00a4b0c4f5b</a></li><li>《modern effective c++》</li><li>《深度探索C++对象模型》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;我理解的右值引用&quot;&gt;&lt;a href=&quot;#我理解的右值引用&quot; class=&quot;headerlink&quot; title=&quot;我理解的右值引用&quot;&gt;&lt;/a&gt;我理解的右值引用&lt;/h1&gt;&lt;p&gt;右值，顾名思义，就是 “=” 号右边的值，通常是个常量或者临时变量，比如代码：&lt;br&gt;&lt;fi
      
    
    </summary>
    
    
      <category term="stl" scheme="http://lida.site/tags/stl/"/>
    
      <category term="cpp11" scheme="http://lida.site/tags/cpp11/"/>
    
      <category term="cpp14" scheme="http://lida.site/tags/cpp14/"/>
    
      <category term="rvalue" scheme="http://lida.site/tags/rvalue/"/>
    
      <category term="std::move" scheme="http://lida.site/tags/std-move/"/>
    
      <category term="右值引用" scheme="http://lida.site/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    
      <category term="性能优化" scheme="http://lida.site/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Modern C++ 插入元素到容器的正确做法</title>
    <link href="http://lida.site/2019/04/25/Modern-C-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E5%88%B0%E5%AE%B9%E5%99%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95/"/>
    <id>http://lida.site/2019/04/25/Modern-C-插入元素到容器的正确做法/</id>
    <published>2019-04-25T07:38:55.000Z</published>
    <updated>2019-04-25T08:04:01.911Z</updated>
    
    <content type="html"><![CDATA[<p>在C++98标准中, 我们向vector或者map等常用容器中插入新的元素时,只能使用push_back和insert, 这两个函数不可避免的调用了复制构造函数,导致不必要的复制行为发生.在C++11以及之后的标准中,插入元素这一行为多了一个选项,那就是 emplace.<br>那么, 他和push_back以及insert 的区别是什么呢? 顾名思义, emplace的字面意思是从内部构造, 如果我们写过模板函数,给出一个类型T,我们可以自己去构造一个T而不是要求外部传入T的实例, 考虑到以下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Foo(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s) : m_s(s) &#123;&#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_s;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Foo&gt; foos;</div><div class="line"><span class="comment">// push_back用法:</span></div><div class="line">foos.push_back(Foo(<span class="string">"bar"</span>));</div><div class="line"><span class="comment">//emplace_back用法:</span></div><div class="line">foos.emplace_back(<span class="string">"bar"</span>);</div></pre></td></tr></table></figure><p>push_back 是要求给一个Foo的实例,然后进行插入, 而emplace_back 只需要给出类型的构造实参即可, emplace_back通过完美转发的方式, 直接把实参转发给容器元素的类型,然后在内部构造一个新的元素实例,这样就避免了拷贝.</p><p>以上是vector容器的用法,那么map容器有两个类型, TKey和TValue, emplace的参数如何传递呢?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Foo&gt; foos;</div><div class="line"><span class="comment">//传统insert的用法:</span></div><div class="line">foos.insert(<span class="number">10</span>, Foo(<span class="string">"bar1"</span>));</div><div class="line"><span class="comment">//emplace的用法之一,但是仍然无法避免拷贝:</span></div><div class="line">foos.emplace(<span class="number">11</span>, Foo(<span class="string">"bar2"</span>));</div><div class="line"><span class="comment">//empalce完美转发的用法,可以完全避免拷贝:</span></div><div class="line">foos.emplace(<span class="built_in">std</span>::piecewise_construct, <span class="built_in">std</span>::forward_as_tuple(<span class="number">12</span>), <span class="built_in">std</span>::forward_as_tuple(<span class="string">"bar3"</span>));</div></pre></td></tr></table></figure><p>从语法上来说, map的emplace传参要解决的问题就是,如何区分TKey的构造实参和TValue的构造实参, map通过std::piecewise_construct和 tuple完美解决了这一问题, tuple可以容纳任意类型任意个数的参数, 在函数收到一个tuple时,也可以通过一些方法进行unpack, 所以不难想象, emplace内部是把第二个和第三个实参进行unpack后forward到TKey的构造函数和TValue的构造函数.</p><p>有了emplace后, 基本上就不会再用push_back和insert了,emplace完全可以做到同样的事情,但是性能会提升很多.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在C++98标准中, 我们向vector或者map等常用容器中插入新的元素时,只能使用push_back和insert, 这两个函数不可避免的调用了复制构造函数,导致不必要的复制行为发生.在C++11以及之后的标准中,插入元素这一行为多了一个选项,那就是 emplace.&lt;
      
    
    </summary>
    
    
      <category term="stl" scheme="http://lida.site/tags/stl/"/>
    
      <category term="cpp11" scheme="http://lida.site/tags/cpp11/"/>
    
      <category term="cpp14" scheme="http://lida.site/tags/cpp14/"/>
    
      <category term="map" scheme="http://lida.site/tags/map/"/>
    
      <category term="vector" scheme="http://lida.site/tags/vector/"/>
    
      <category term="perfect forward" scheme="http://lida.site/tags/perfect-forward/"/>
    
      <category term="emplace" scheme="http://lida.site/tags/emplace/"/>
    
  </entry>
  
  <entry>
    <title>端口明明已经监听了为什么还是访问不了呢</title>
    <link href="http://lida.site/2019/04/09/%E7%AB%AF%E5%8F%A3%E6%98%8E%E6%98%8E%E5%B7%B2%E7%BB%8F%E7%9B%91%E5%90%AC%E4%BA%86%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%98%AF%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%E5%91%A2/"/>
    <id>http://lida.site/2019/04/09/端口明明已经监听了为什么还是访问不了呢/</id>
    <published>2019-04-09T08:17:12.000Z</published>
    <updated>2019-04-10T07:46:51.971Z</updated>
    
    <content type="html"><![CDATA[<p>有一个mysql,是通过docker启动的, 端口是3306, network是host模式, 直接使用本机ip监听端口.<br>某天服务器重启以后怎么样都没办法访问3306端口.<br>netstat查看确实3306端口处于监听状态<br>但是可以127.0.0.1:3306 这样访问<br>把服务关掉后<br>观察到 telnet {hostIp} 3306 会一直trying, 而正常没有监听的端口是直接报错connect refused<br>所以怀疑是不是被劫持了<br>查看iptables, 发现有几个和3306相关的东西:</p><p>命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo iptables -t nat -L --line-numbers</div><div class="line">sudo iptables -t filter -L --line-numbers</div><div class="line">sudo iptables -t raw -L --line-numbers</div><div class="line">sudo iptables -L -t mangle --line-numbers</div></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Chain DOCKER (3 references)</div><div class="line">num  target     prot opt source               destination         </div><div class="line">1    ACCEPT     tcp  --  anywhere             172.20.0.101         tcp dpt:mysql</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Chain POSTROUTING (policy ACCEPT)</div><div class="line">num  target     prot opt source               destination         </div><div class="line">1    MASQUERADE  all  --  172.20.0.0/16        anywhere            </div><div class="line">5    MASQUERADE  tcp  --  172.20.0.101         172.20.0.101         tcp dpt:mysql</div></pre></td></tr></table></figure><p>因为172.20这个ip完全陌生,所以备份之后尝试删除,删除之后就没问题了</p><p>删除命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo iptables -t nat -D DOCKER 4</div><div class="line">sudo iptables -t nat -D POSTROUTING 1</div><div class="line">sudo iptables -t filter -D DOCKER 1</div></pre></td></tr></table></figure></p><p>删完记得保存配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo su</div><div class="line">iptables-save &gt; /etc/iptables-rules</div></pre></td></tr></table></figure><p>问题解决.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有一个mysql,是通过docker启动的, 端口是3306, network是host模式, 直接使用本机ip监听端口.&lt;br&gt;某天服务器重启以后怎么样都没办法访问3306端口.&lt;br&gt;netstat查看确实3306端口处于监听状态&lt;br&gt;但是可以127.0.0.1:33
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阿里云redis迁移到pika</title>
    <link href="http://lida.site/2018/11/02/%E9%98%BF%E9%87%8C%E4%BA%91redis%E8%BF%81%E7%A7%BB%E5%88%B0pika/"/>
    <id>http://lida.site/2018/11/02/阿里云redis迁移到pika/</id>
    <published>2018-11-02T13:15:39.000Z</published>
    <updated>2018-12-10T09:05:00.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>项目要求快速上线,因为redis支持丰富的数据结构,所以开发初期便把部分数据直接存储到redis,几个月之后用户量上来了,累积了很多数据,其中绝大多数都是冷数据,用户一百年也不会访问一次的.相比磁盘来说,内存虽然快但是很贵,而这部分数据没必要放在内存中.于是就要想办法把这部分数据迁移出来.</p><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>这种事情以前干过一次,把这部分数据迁移到mysql,但是这样做的麻烦之处在于要修改整个存储逻辑,因为使用sql和nosql的整个设计思路都是不一样的,很多地方要用完全不同的实现方式,工作量巨大且风险高.<br>其实仔细思考,redis的协议并不只是适用于纯内存数据库,我的需求就是兼容redis协议,但是能把部分冷数据落地到磁盘,然后从内存中清除,当有请求过来时再把这部分数据load到内存.<br>所以最开始的思路是使用redis-rdb-tools导出所有key以及key占用的size,分析当前redis内究竟是哪种类型的key占用了最大的内存,然后做一个proxy,把这部分key的redis请求发送到proxy, 在proxy上把相关命令的协议实现,然后实现刚才提到的缓存的逻辑.<br>后来,我google了一下,发现了<a href="https://github.com/Qihoo360/pika" target="_blank" rel="external">pika</a>数据库,似乎可以完美的适应我的需求,看到测试数据,性能大概是redis的50%,完全够用了.</p><h2 id="Converting-amp-Importing"><a href="#Converting-amp-Importing" class="headerlink" title="Converting&amp;Importing"></a>Converting&amp;Importing</h2><p>pika项目组提供了一个数据导入的<a href="https://github.com/Qihoo360/pika/wiki/Redis%E5%88%B0pika%E8%BF%81%E7%A7%BB%E5%B7%A5%E5%85%B7" target="_blank" rel="external">工具</a>,功能和redis-cli –pipe一样,通过管道批量执行命令,这种导入只适用于appendonly.aof文件,并不适用于dump.rdb文件<br>其实如果是正常自建的redis,完全可以开启appendonly落地模式,然后使用这个工具,在导入完完整的appendonly文件后,继续导入新增的数据,可以实现线上不停机的平滑迁移.<br>可惜阿里云的Redis服务不提供appendonly文件, 也不提供sync/psync命令,所以没法做平滑迁移.<br>最后采用的方案是在迁移过程中让业务侧停止写入,迁移完成后再开放.<br>从阿里云上拿到的redis数据文件是dump文件,如何把他变成appendonly格式的文件也是个问题.自然而然的想到先用redis-server读取dump文件,然后关掉save,开启appendonly模式,执行bgrewriteaof命令生成一个appendonly.aof文件.<br>这个方案在迁移第一个库的时候管用,在迁移第二个库时就不行了,因为第二个库太大,load到内存后,没有办法再开启一个同样内存大小的异步进程去rewrite.<br>为了解决这个问题,我使用了<a href="https://github.com/sripathikrishnan/redis-rdb-tools" target="_blank" rel="external">redis-rdb-tools</a>,这个工具可以读取dump文件把aof格式的协议数据输出到标准输出流.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup rdb -n 1 --command protocol ./dump.rdb | redis-cli -p 6380  --pipe &amp;   //-n 1表示只导入idx为1的库(select 1)</div></pre></td></tr></table></figure></p><h2 id="Check-amp-Test"><a href="#Check-amp-Test" class="headerlink" title="Check&amp;Test"></a>Check&amp;Test</h2><p>在线上环境找了一台负载不高的机器,创建了一个测试库,给线上redis做个快照,然后把数据导入到pika,利用<a href="https://github.com/Qihoo360/pika/wiki/Redis%E8%AF%B7%E6%B1%82%E5%AE%9E%E6%97%B6copy%E5%88%B0pika%E5%B7%A5%E5%85%B7" target="_blank" rel="external">redis-copy</a>工具,把线上环境的redis收到的所有命令都copy到测试库上,以此来检测我们目前用到的命令有哪些是pika不兼容的.<br>通过这个办法,我发现rename命令在pika里面是没有的,使用到rename命令的代码需要修改,只能把要rename的key的value get出来,然后再重新用新的key set回去.</p><h2 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h2><p>删除原库数据时一定要仔细核对,确保迁移过去后,原库的待删除key没有增加,以此保证所有的服务器都指向到了新的pika服务.<br>通过这个流程,最终成功完成了两个业务库的迁移,现在线上环境已经使用pika跑了一周了,暂时没有出现任何异常.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;headerlink&quot; title=&quot;Why&quot;&gt;&lt;/a&gt;Why&lt;/h1&gt;&lt;p&gt;项目要求快速上线,因为redis支持丰富的数据结构,所以开发初期便把部分数据直接存储到redis,几个月之后用户量上来了,累积了很多
      
    
    </summary>
    
    
      <category term="阿里云" scheme="http://lida.site/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="redis" scheme="http://lida.site/tags/redis/"/>
    
      <category term="pika" scheme="http://lida.site/tags/pika/"/>
    
  </entry>
  
  <entry>
    <title>初次使用golang和mongodb开发一个完整产品的一些笔记</title>
    <link href="http://lida.site/2018/11/01/%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8golang%E5%92%8Cmongodb%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E4%BA%A7%E5%93%81%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/"/>
    <id>http://lida.site/2018/11/01/初次使用golang和mongodb开发一个完整产品的一些笔记/</id>
    <published>2018-11-01T12:59:07.000Z</published>
    <updated>2018-11-01T09:54:37.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>几个同行相约用业余时间开发一款社交应用,客户端就是微信公众号H5,因为是个人项目,我就不太想用自己擅长的C++了,麻烦不说,写起来也挺没趣,之前断断续续也用golang写了几个服务,觉得很适合用来写后台,于是技术选型就敲定golang啦.<br>考虑到最好需要业务中用户之间并无太多交集,用非关系型的nosql数据库开发效率更高,在redis和mongodb之间犹豫了许久,最终选了mongodb,原因无他,redis实在是太熟悉,对这东西没啥兴趣了,而且redis纯内存对服务器成本要求也太大,万一到时候用户量上去没有日活,我redis开着吃那么多内存浪费钱嘛.所以就选了mongodb.</p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>产品需求大概就是提供一个看别人发的信息,同时可以领取红包的功能<br>对于发送信息方,付出少量的金钱可以使自己的信息得到传播,比如房屋招租, 寻狗启事等<br>对于接收信息方,查阅信息即可以瓜分到现金,如果帮助传播,则自己的份额+1,可以获得更多的现金<br>盈利模式就是在用户提现时收取几个点的手续费.</p><h1 id="任务拆分"><a href="#任务拆分" class="headerlink" title="任务拆分"></a>任务拆分</h1><p>根据以上需求,可以大概预算到,这样一个项目后台的核心功能<br>1.用户体系<br>2.微信支付以及提现<br>3.便签核心能力<br>4.用户钱包,维护用户余额</p><h2 id="用户体系"><a href="#用户体系" class="headerlink" title="用户体系"></a>用户体系</h2><p>1.新用户进入自动注册和登录<br>2.老用户进入自动登录<br>3.提供gin中间件,给每个登录态接口鉴权,检查用户登录态是否有效</p><h2 id="微信支付以及提现"><a href="#微信支付以及提现" class="headerlink" title="微信支付以及提现"></a>微信支付以及提现</h2><ol><li>用户发布红包便签时提供微信支付功能</li><li>用户通过查看便签获得的红包,在存入余额后申请提现,可以通过企业红包成功提现到自己的微信号上</li><li>提现功能因为需要使用证书,而微信官方并没有提供golang的sdk, 所以借助于python实现,通过celery任务管理框架和golang进行通信</li></ol><h2 id="便签核心能力"><a href="#便签核心能力" class="headerlink" title="便签核心能力"></a>便签核心能力</h2><ol><li>提供管理用户便签的能力,具体如下</li><li>发布便签,先发布一个便签,状态设置为未支付,对未支付便签进行限制,不允许通过关注未支付便签瓜分红包和分享. 使用微信统一下单,获取支付参数下发给前端,前端通过支付参数包调起微信支付,支付成功后收到回调,回调中把便签支付状态修改为已支付,完成整个发布流程.</li><li>订阅便签,用户通过订阅和查看其他人发布的便签获得红包瓜分份额,自己订阅份额+1,分享出去后别人通过你的分享进来便签页,自己的订阅份额也+1.</li><li>瓜分红包,当某个便签的到达指定时间点后,用户可以根据自己的份额进行瓜分,瓜分到的现金存入余额.</li></ol><h2 id="用户钱包-维护用户余额"><a href="#用户钱包-维护用户余额" class="headerlink" title="用户钱包,维护用户余额"></a>用户钱包,维护用户余额</h2><ol><li>提供取现功能和存入余额功能</li><li>提现功能注意处理数据一致性,不能让用户通过并发手段把一份钱取多次,这里借助了mongodb的findAndModify功能,并发去写入一个flag,最终写入成功的只有一个,只有写成功的线程才可以继续执行下面的提现操作.</li><li>存入余额这里也需要注意数据一致性,不能让用户通过并发手段把一个红包应该分得的钱多次存入余额,这里借助了mongodb的findAndModify功能,并发去写入一个flag,最终写成功的只有一个,只有写成功的线程才可以继续执行下面的存入余额操作.</li></ol><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构:"></a>项目结构:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">├── Authorize   //用户认证,包括用户登录,登陆后token鉴权</div><div class="line">├── CeleryTasks  //Celery脚本, 用于访问微信api和海报生成</div><div class="line">├── CeleryWrapper  //go访问celery的wrapper</div><div class="line">├── cert  //微信证书</div><div class="line">├── Common  //公共代码,很多地方需要使用的公共函数放在这里,如从头中获取userId,生成一个新的userId,获取一个mongodb的session等</div><div class="line">├── config   //配置文件,如微信支付的相关配置,mongodb地址的配置等</div><div class="line">├── ConfigManager  //配置管理器,用于在任何地方都可以方便的读取配置</div><div class="line">├── ErrorCodes   //错误码定义</div><div class="line">├── Handlers   //消息处理代码</div><div class="line">├── ImageProcessor   //图片处理器,因为海报生成部分最后使用celery配合wkhtmltopdf把html转图片,所以这部分代码废弃</div><div class="line">├── Logger  //日志相关代码,日志打印使用了logrus库,这里把logrus包装成一个middleware和gin框架结合使用,最终的目的是让gin框架把请求和回包日志用logrus打印出来</div><div class="line">├── NoteManager  //便签管理,和便签相关的代码都在这里面</div><div class="line">├── Pay     //支付相关</div><div class="line">│   └── WechatPay   //目前只支持微信支付,和微信支付相关的代码都在这里</div><div class="line">├── Resources   //图片等静态资源</div><div class="line">└── UserManager   //用户管理,和用户相关的代码都在这里</div></pre></td></tr></table></figure><h1 id="一些随想"><a href="#一些随想" class="headerlink" title="一些随想"></a>一些随想</h1><ol><li>通过开发这个项目,让自己对golang有一个比较全面的了解,熟悉了golang代码的组织形式,第三方库的路径之类的golang开发环境特有的一些问题</li><li>golang严格定义了一些其他语言里面灵活的东西,比如括号问题,函数的开始括号一定要在函数声明的第一行,这一点我觉得很赞,其实很多东西不太需要自由,方案a也行b也行,但是如果没人拍板就会制造混乱,如果硬性规定统一一下就很好.</li><li>golang的警告不完全消除就不允许编译通过,这个特性我看到的时候心里默默点了个赞,但是开发完一套程序就想说mmp了,很多时候写测试代码时,经常会屏蔽某些代码,就会导致notused的warnning,然后导致程序无法编译通过,只有把声明变量或者import的语句注释掉才可以编译过,很难受.</li><li>golang的代码风格是使用返回值来返回错误码, 因为golang支持多返回值,所以通常第一个返回值表示真正要返回的数据,第二个返回值表示错误码, 这个会导致错误处理的代码冗余,如果层级调用过深,每个层级都需要处理很多错误码.但是好处是编写代码的时候会自觉的处理好能想到的异常情况</li><li>golang弱化了面向对象的概念,其实我觉得面向对象在几年前很火,但是很多中小型项目基本上用不到,所以弄出什么单例模式,其实就是面向对象的退化.golang可以允许函数单独的存在,这一点我觉得非常赞.毕竟后台开发更重要的是并发而不是所谓的模式.</li><li>从语言层面提供goroutine这种功能真的特别赞.有人说C++也有协程(windows上叫纤程(Fiber)),这玩意其实不新鲜,2012年我们研发游戏时就用到过,当时没有第三方库可参考,都是自己手撸代码,后来在16年的时候看到腾讯出了一个libco,通过hook socket相关函数的方式无痛改造,把所有的socket操作都变成异步的. 我马上把这个库用在了当时项目的thrift框架上, 记得当时的成绩是让8核机器可以跑满7个核, 比全同步只能跑满4个核好了不少, 吞吐量也上去了, 但是费了不少劲. 把thrift的线程池改造成了协程池. 所以用C++搞协程,要操心很多地方,主要是第三方库不好改, 腾讯的libco算是另辟蹊径了. golang的伟大之处是把这东西固化到语言里面,直接让所有第三方库全异步.</li><li>golang作为最近几年大火的语言,第三方库却始终跟不上,让人很奇怪,比如mongodb这么多年了,竟然都没有一个官方的drive, 最流行的mgo是一个第三方库.很多功能如果借助python实现会方便很多.这里不得不感慨python确实是开发效率很高的开发环境.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h1&gt;&lt;p&gt;几个同行相约用业余时间开发一款社交应用,客户端就是微信公众号H5,因为是个人项目,我就不太想用自己擅长的C++了,麻烦不说,写起来也挺没趣,
      
    
    </summary>
    
    
      <category term="redis" scheme="http://lida.site/tags/redis/"/>
    
      <category term="golang" scheme="http://lida.site/tags/golang/"/>
    
      <category term="mongodb" scheme="http://lida.site/tags/mongodb/"/>
    
      <category term="wechat" scheme="http://lida.site/tags/wechat/"/>
    
      <category term="python" scheme="http://lida.site/tags/python/"/>
    
      <category term="celery" scheme="http://lida.site/tags/celery/"/>
    
      <category term="微信公众号" scheme="http://lida.site/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="微信支付" scheme="http://lida.site/tags/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>使用nginx+lua实现对阿里云OSS文件的实时解密</title>
    <link href="http://lida.site/2017/11/07/%E4%BD%BF%E7%94%A8nginx-lua%E5%AE%9E%E7%8E%B0%E5%AF%B9%E9%98%BF%E9%87%8C%E4%BA%91OSS%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9E%E6%97%B6%E8%A7%A3%E5%AF%86/"/>
    <id>http://lida.site/2017/11/07/使用nginx-lua实现对阿里云OSS文件的实时解密/</id>
    <published>2017-11-07T08:03:47.000Z</published>
    <updated>2017-11-07T09:04:23.427Z</updated>
    
    <content type="html"><![CDATA[<p>临时接到一个需求,有一个巨大的资源池,传到阿里云的OSS上了,坑爹的是资源池内的文件全是加密的.临上线了才发现这个坑.为了安全也不能把未加密的文件对外传输.所以就得想办法实时解密.</p><p>首先想到的就是通过一个反向代理来转发,代理收到内容后,解密然后再回包.</p><p>所以首选Nginx了, 虽然我们一直用Nginx作为网关,但是我对其还处于完全不了解的状态,趁机恶补一下知识, 花了2个小时看了淘宝团队写的<a href="http://tengine.taobao.org/book/" target="_blank" rel="external">Nginx开发从入门到精通</a>,最后发现,添加一个module竟然要重新编译nginx?? What the fuck!这不科学…</p><p>于是寻寻觅觅,发现了lua-nginx-module,进而发现了已经打包好的openresty.</p><p>之前接触过云风大神写的<a href="https://github.com/cloudwu/skynet" target="_blank" rel="external">skynet</a>游戏服务端框架,也是使用lua作为开发语言,使用lua的协程特性可以很方便的把异步代码”逻辑同步化”,不过我这次需要实现的解密功能,是属于典型的CPU密集型的应用,和同步异步没啥关系…<br>如果用脚本语言实现加解密算法,性能可想而知,不过还好,发现了一个叫lua-resty-nettle的加解密库,加解密算法都是native实现的,lua只是作为胶水.所以性能基本上放心了.<br>再加上找京东的同事考证了一下,他们内部确实也使用了这个东西,所以稳定性应该是没有问题.</p><p>技术方案定了,接下来就是写代码了.</p><p>看了一下<a href="https://github.com/openresty/lua-nginx-module" target="_blank" rel="external">官方文档</a>,lua-nginx-module提供了很多钩子,可以让你通过lua代码去处理,找出我现在最需要的几个钩子:</p><ul><li>body_filter_by_lua<br>把反向代理获取到的body传入自己编写的lua代码中进行处理,需要注意的是这里传入的是一个一个”chunk”,载入一个页面,可能会分为好几次调用过来,所以我们编写的lua代码需要处理这种情况</li><li>rewrite_by_lua_block<br>可以使用lua代码对url进行重写,需要用这个的原因是因为资源池以前是在windows上,之前大小写不敏感,导致很多地方的url引用不区分大小写也可以正常使用, 所以现在迁移到OSS后,大小写敏感了.为了兼容这种情况,只能把所有的文件名全部转换为小写,然后把所有转发请求的url都rewrite为小写</li><li>header_filter_by_lua_block<br>可以使用lua代码重写http头.因为回包经过解密后length变了,所以需要把content_length设为空,这样浏览器就可以识别body是chunk的方式传输的,还需要把content_encoding设为nil,否则oss会根据大部分浏览器的请求,返回一个gzip压缩过的数据,为了处理方便,这里就强行把gzip给关了当然,通过这个钩子只能处理被代理方回包的http头,具体如何强行关闭gzip,后面再说.</li></ul><p>具体配置如下:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="attribute">error_log</span>  logs/error.log  <span class="literal">info</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="section">events</span> &#123;</div><div class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="section">http</span> &#123;</div><div class="line">    <span class="attribute">include</span>       mime.types;</div><div class="line">    <span class="attribute">default_type</span>  application/octet-stream;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</div><div class="line"></div><div class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</div><div class="line"></div><div class="line">    <span class="section">server</span> &#123;</div><div class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</div><div class="line">        <span class="attribute">server_name</span>  localhost;</div><div class="line"></div><div class="line">        <span class="attribute">location</span> / &#123;</div><div class="line">                 <span class="attribute">proxy_pass</span>     http://资源池的地址;</div><div class="line">                 <span class="attribute">proxy_set_header</span> Accept-Encoding <span class="string">""</span>;</div><div class="line">                 <span class="section">rewrite_by_lua_block</span> &#123;</div><div class="line">                      ngx.req.set_uri(string.lower(ngx.var.uri))</div><div class="line">                 &#125;</div><div class="line">                 <span class="section">header_filter_by_lua_block</span> &#123;</div><div class="line">                      ngx.header.content_length = nil</div><div class="line">                      ngx.header.content_encoding = nil</div><div class="line">                 &#125;</div><div class="line">                 <span class="attribute">body_filter_by_lua_file</span> /path/to/lua/resource_decrypt.lua;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意这一行:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">proxy_set_header</span> Accept-Encoding <span class="string">""</span>;</div></pre></td></tr></table></figure><p>使用 proxy_set_header 功能,强行屏蔽掉浏览器gzip压缩格式的请求.所以到被代理方,也就是资源池的请求,永远是不压缩的.</p><p>因为lua代码比较长,所以为了方便把它放到一个文件里面了, 然后通过body_filter_by_lua_file 指定文件,效果和body_filter_by_lua是一样的</p><p>lua代码如下:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> data, eof = ngx.<span class="built_in">arg</span>[<span class="number">1</span>], ngx.<span class="built_in">arg</span>[<span class="number">2</span>]</div><div class="line"><span class="keyword">local</span> des = <span class="built_in">require</span> <span class="string">"resty.nettle.des"</span></div><div class="line"><span class="keyword">local</span> buffered = ngx.ctx.buffered</div><div class="line"><span class="keyword">local</span> bufferedSize = ngx.ctx.bufferedSize</div><div class="line"><span class="keyword">local</span> packageSize = <span class="number">2048000</span> <span class="comment">-- 2m</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> bufferedSize <span class="keyword">then</span></div><div class="line">   bufferedSize = <span class="number">0</span></div><div class="line">   ngx.ctx.bufferedSize = bufferedSize</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ngx.ctx.bufferedSize &lt;= packageSize <span class="keyword">then</span></div><div class="line">   <span class="keyword">if</span> <span class="keyword">not</span> buffered <span class="keyword">then</span></div><div class="line">      buffered = &#123;&#125;</div><div class="line">      ngx.ctx.buffered = buffered</div><div class="line">   <span class="keyword">end</span></div><div class="line">   <span class="keyword">if</span> data ~= <span class="string">""</span> <span class="keyword">then</span></div><div class="line">      buffered[#buffered+<span class="number">1</span>] = data</div><div class="line">      bufferedSize = bufferedSize + #data</div><div class="line">      <span class="keyword">if</span> bufferedSize &gt; packageSize <span class="keyword">then</span></div><div class="line">         ngx.<span class="built_in">arg</span>[<span class="number">1</span>] = <span class="built_in">table</span>.<span class="built_in">concat</span>(buffered)</div><div class="line">         ngx.ctx.buffered = <span class="literal">nil</span></div><div class="line">         <span class="keyword">if</span> eof <span class="keyword">then</span></div><div class="line">            ngx.ctx.bufferedSize = <span class="literal">nil</span></div><div class="line">         <span class="keyword">end</span></div><div class="line">         <span class="keyword">return</span></div><div class="line">      <span class="keyword">else</span></div><div class="line">         ngx.<span class="built_in">arg</span>[<span class="number">1</span>] = <span class="literal">nil</span></div><div class="line">      <span class="keyword">end</span></div><div class="line">   <span class="keyword">end</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   ngx.<span class="built_in">arg</span>[<span class="number">1</span>] = data</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> eof <span class="keyword">then</span></div><div class="line">   <span class="keyword">local</span> whole = <span class="built_in">table</span>.<span class="built_in">concat</span>(buffered)</div><div class="line">   ngx.ctx.buffered = <span class="literal">nil</span></div><div class="line">   ngx.ctx.bufferedSize = <span class="literal">nil</span></div><div class="line">   <span class="keyword">local</span> ds, wk = des.new(<span class="string">"password"</span>, <span class="string">"cbc"</span>, <span class="string">"iv"</span>)</div><div class="line">   <span class="keyword">local</span> raw = ds:decrypt(whole)</div><div class="line">   ngx.<span class="built_in">arg</span>[<span class="number">1</span>] = <span class="built_in">string</span>.<span class="built_in">sub</span>(raw, <span class="number">1</span>, #raw - <span class="built_in">string</span>.<span class="built_in">byte</span>(raw, #raw))  <span class="comment">-- 需要取最后一个字符作为长度,在解密的字符串中删除掉这个长度的字符数</span></div><div class="line">   ngx.<span class="built_in">arg</span>[<span class="number">2</span>] = <span class="literal">true</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>ngx.arg[1]表示当前数据 ngx.arg[2]表示当前数据是否是最后一个chunk.<br>对ngx.arg[1]赋值表示要传给最终用户(浏览器)的数据,所以处理完数据后别忘了赋值给ngx.arg[1]<br>因为数据不是一次性发过来的,所以需要进行拼包,如果发现某个文件过大,就不解密直接raw过去<br>lua代码中用到了ngx.ctx.*, 这个是lua-nginx-module提供的一个global的table,可以用来暂存任意数据.当一个完整的文件没有传送完成时,之前传送的部分就存在这里.</p><p>为了解密des,用到了一个第三方lua库,openresty提供了包管理器,可以使用以下命令安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo opm get bungle/lua-resty-nettle</div></pre></td></tr></table></figure><p>还有一个需要注意的是,des解密后出来的文件总是对不上,后面会莫名其妙多出几个byte,查阅资料后发现,原来PKCS5Padding会填充长度为8的倍数,处理这个问题也很简单,把最后一个byte拿出来作为冗余数据的长度,从解密数据中删除尾部的这个长度的数据即可.</p><p>花了一天从确定技术方案到开发完成,保证了项目上线时间.还是蛮有成就感的.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;临时接到一个需求,有一个巨大的资源池,传到阿里云的OSS上了,坑爹的是资源池内的文件全是加密的.临上线了才发现这个坑.为了安全也不能把未加密的文件对外传输.所以就得想办法实时解密.&lt;/p&gt;
&lt;p&gt;首先想到的就是通过一个反向代理来转发,代理收到内容后,解密然后再回包.&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://lida.site/tags/nginx/"/>
    
      <category term="lua" scheme="http://lida.site/tags/lua/"/>
    
      <category term="openresty" scheme="http://lida.site/tags/openresty/"/>
    
      <category term="des" scheme="http://lida.site/tags/des/"/>
    
      <category term="阿里云" scheme="http://lida.site/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="oss" scheme="http://lida.site/tags/oss/"/>
    
  </entry>
  
  <entry>
    <title>通过使用C++变参模板动态生成重载函数来解决Tars框架的消息转发问题</title>
    <link href="http://lida.site/2017/11/02/%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8C++%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E6%9D%A5%E8%A7%A3%E5%86%B3Tars%E6%A1%86%E6%9E%B6%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    <id>http://lida.site/2017/11/02/通过使用C++变参模板动态生成重载函数来解决Tars框架的消息转发问题/</id>
    <published>2017-11-02T02:38:12.000Z</published>
    <updated>2017-11-06T07:00:03.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fantastic"><a href="#Fantastic" class="headerlink" title="Fantastic"></a>Fantastic</h1><p>C++14有很多新特性,但是最让人着迷的,莫过于变参模板了,变参模板把函数式的编程思想在C++中发挥得淋漓尽致,让C++的灵活性提升了一个level,使用变参模板,可以写出看起来像是动态语言特性的代码.<br>最近遇到一个问题,如果没有变参模板,还真不知道该如何解决.</p><h1 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h1><p>我们的后台程序使用了Tars框架,他的IDL生成出来的C++代码中,有一个Callback类用来表示异步调用的回调,定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FakeCallbackBase</span> &#123;</span></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">callback_fakeRequestName</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">const</span> FakeResponse2 &amp;a1, <span class="keyword">const</span> FakeResponse&amp; a2)</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"no implement"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">callback_fakeRequestName_exception</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">const</span> FakeResponse2 &amp;a1, <span class="keyword">const</span> FakeResponse&amp; a2)</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"no implement"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>一眼看上去似乎也没什么问题,每个请求对应一个虚函数,要处理这个请求的callback,只需要重载对应的虚函数即可.<br>就处理业务逻辑来说,其实没啥太大问题.<br>但是,我现在要写的是一个Proxy,主要负责把内部的Tars接口使用开放的HTTP协议对外暴露,所以对每一个接口的业务逻辑都是一样的.我可不想把同一份代码不停的Copy &amp; Paste.<br>So… 我想到一个办法,变参模板!</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>分析上面的回调函数的定义,发现参数列表有如下规律:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">第一个参数是RPC的返回值,类似于函数的返回值,只有一个,后面的所有参数表示的是RPC的出参,是一个*可变列表*</div></pre></td></tr></table></figure><p>定义这样一个宏,方便用来给每一个RPC生成统一的Callback类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFINE_FORWARD_CALLBACK</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_FORWARD_CALLBACK(requestName) \</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForwardFor_</span>##<span class="title">requestName</span> &#123;</span>     \</div><div class="line"><span class="keyword">public</span>:                              \</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TREQS&gt; \</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Forward</span> &#123;</span> \</div><div class="line"><span class="keyword">public</span>: \</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TR&gt;\</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Return</span> &#123;</span>\</div><div class="line">        <span class="keyword">public</span>:\</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TF, <span class="keyword">typename</span> TCONTEXT, <span class="keyword">typename</span>... TRSPS&gt; \</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Callback</span> :</span> <span class="keyword">public</span> TF &#123;\</div><div class="line">        <span class="keyword">public</span>:                                                         \</div><div class="line">            Callback(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">typename</span> ForwardHelper::Forward&lt;TREQS...&gt;::<span class="keyword">template</span> Return&lt;TR&gt;::<span class="keyword">template</span> CallbackProcesserBase&lt;TCONTEXT, TRSPS...&gt;&gt; processer, <span class="keyword">const</span> TCONTEXT&amp; context, <span class="keyword">const</span> TREQS&amp;... tReqs) \</div><div class="line">            : m_processer(processer), m_context(context) &#123;                     \</div><div class="line">                m_processer-&gt;onRequest(m_context, <span class="built_in">std</span>::<span class="built_in">string</span>(#requestName), tReqs...); \</div><div class="line">            &#125;                                                           \</div><div class="line">            <span class="keyword">virtual</span> <span class="keyword">void</span> callback_##requestName(TR ret, TRSPS... rsps) &#123; \</div><div class="line">                m_processer-&gt;onCallback(m_context, <span class="built_in">std</span>::<span class="built_in">string</span>(#requestName), ret, rsps...); \</div><div class="line">            &#125;                                                           \</div><div class="line">            <span class="keyword">virtual</span> <span class="keyword">void</span> callback_##requestName##_exception(TR ret) &#123;\</div><div class="line">                m_processer-&gt;onCallbackException(m_context, <span class="built_in">std</span>::<span class="built_in">string</span>(#requestName), ret); \</div><div class="line">            &#125;\</div><div class="line">        <span class="keyword">private</span>:\</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">typename</span> ForwardHelper::Forward&lt;TREQS...&gt;::<span class="keyword">template</span> Return&lt;TR&gt;::<span class="keyword">template</span> CallbackProcesserBase&lt;TCONTEXT, TRSPS...&gt;&gt; m_processer; \</div><div class="line">            TCONTEXT m_context;                                         \</div><div class="line">        &#125;;\</div><div class="line">    <span class="keyword">private</span>:\</div><div class="line">        Return()&#123;&#125;\</div><div class="line">        Return(<span class="keyword">const</span> Return&amp;)&#123;&#125;\</div><div class="line">    &#125;;\</div><div class="line"><span class="keyword">private</span>:\</div><div class="line">    Forward()&#123;&#125;                                    \</div><div class="line">    Forward(<span class="keyword">const</span> ForwardFor_##requestName&amp;)&#123;&#125;                  \</div><div class="line">&#125;;                                                              \</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure><p>使用嵌套类是为了区分请求参数类型列表和回包(出参)参数类型列表<br>Forward类的模板参数是请求参数列表<br>Callback类的模板参数是回包参数列表<br>TCONTEXT是callback允许外带的一个上下文,方便发包和收包的逻辑衔接<br>TF是这个宏生成出来的类的基类,本例中就是上面出现的FakeCallbackBase<br>m_processer是用来统一处理所有回包的一个处理器,我们把<em>静态的代码转换为动态的代码</em>,靠的就是这个m_processer</p><p>下面来看一下Processer的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> ForwardHelper &#123;</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TREQS&gt;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Forward</span> &#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TR&gt;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Return</span> &#123;</span></div><div class="line">        <span class="keyword">public</span>:</div><div class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TCONTEXT, <span class="keyword">typename</span>... TRSPS&gt;</div><div class="line">            <span class="class"><span class="keyword">class</span> <span class="title">CallbackProcesserBase</span> &#123;</span></div><div class="line">            <span class="keyword">public</span>:</div><div class="line">                <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onRequest</span><span class="params">(TCONTEXT&amp; m_context, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; requestName, <span class="keyword">const</span> TREQS&amp;... tReqs)</span> </span>= <span class="number">0</span>;</div><div class="line">                <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onCallbackException</span><span class="params">(TCONTEXT&amp; m_context, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; requestName, TR t)</span> </span>= <span class="number">0</span>;</div><div class="line">                <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onCallback</span><span class="params">(TCONTEXT&amp; m_context, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; requestName, TR t, TRSPS... rsps)</span> </span>= <span class="number">0</span>;</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>CallbackProcesserBase 就是Processer的基类,因为我们要实现的是HTTP的转发,所以使用一个派生类来实现以上的接口定义,代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TREQS&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPForward</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TR&gt;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Return</span> &#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TRSPS&gt;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MultiReqRspGenericHttpProcesser</span> :</span> <span class="keyword">public</span> ForwardHelper::Forward&lt;TREQS...&gt;::<span class="keyword">template</span> Return&lt;TR&gt;::<span class="keyword">template</span> CallbackProcesserBase&lt;tars::TarsCurrentPtr, TRSPS...&gt; &#123;</div><div class="line">        <span class="keyword">public</span>:</div><div class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onRequest</span><span class="params">(tars::TarsCurrentPtr &amp;current, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; requestName, <span class="keyword">const</span> TREQS&amp;... tReqs)</span> </span>&#123;</div><div class="line">                m_startTime = TNOWMS;</div><div class="line">                getStringStreamByMultiParam(m_ossReq, tReqs...);</div><div class="line">                FDLOG(<span class="string">"protocol"</span>) &lt;&lt; requestName &lt;&lt; <span class="string">"|REQ|"</span> &lt;&lt; m_ossReq.str() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onCallbackException</span><span class="params">(tars::TarsCurrentPtr &amp;current, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; requestName, TR ret)</span> </span>&#123;</div><div class="line">                ERRORLOG &lt;&lt; requestName &lt;&lt; <span class="string">"|REQ|"</span> &lt;&lt; m_ossReq.str() &lt;&lt; <span class="string">"|"</span> &lt;&lt; ret &lt;&lt; <span class="string">"|"</span> &lt;&lt; getCostInMS() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">processCallback</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;bodies, <span class="built_in">std</span>::<span class="built_in">ostringstream</span> &amp;oss)</span> </span>&#123;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">processCallback</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;bodies, <span class="built_in">std</span>::<span class="built_in">ostringstream</span> &amp;oss, T lastOneOfRSPS)</span> </span>&#123;</div><div class="line">                bodies.emplace_back();</div><div class="line">                tarsEncode(lastOneOfRSPS, *bodies.rbegin());</div><div class="line">                oss &lt;&lt; lastOneOfRSPS;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... TRSPS2&gt;</div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">processCallback</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;bodies, <span class="built_in">std</span>::<span class="built_in">ostringstream</span> &amp;oss, T oneOfRSPS,  TRSPS2... rsps)</span> </span>&#123;</div><div class="line">                bodies.emplace_back();</div><div class="line">                tarsEncode(oneOfRSPS, *bodies.rbegin());</div><div class="line">                oss &lt;&lt; oneOfRSPS &lt;&lt; <span class="string">"|"</span>;</div><div class="line">                processCallback(bodies, oss, rsps...);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onCallback</span><span class="params">(tars::TarsCurrentPtr &amp;current, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; requestName, TR ret, TRSPS... rsps)</span> </span>&#123;</div><div class="line">                <span class="comment">//打包rsps, 然后使用current对proxy的调用方回包,从而实现统一的转发</span></div><div class="line">                <span class="built_in">std</span>::<span class="built_in">ostringstream</span> ossRsp;  <span class="comment">//日志使用</span></div><div class="line">                ResponseModern rsp;</div><div class="line">                processCallback(rsp.outParams, ossRsp, rsps...); <span class="comment">//这一行对rsps进行拆包,然后一个一个Encode到一个std::vector&lt;std::string&gt;(也就是rsp.outParams)中</span></div><div class="line">                rsp.result.retCode = ret;</div><div class="line">                <span class="built_in">string</span> body;</div><div class="line">                tarsEncode(rsp,body); <span class="comment">//最后把最外层的rsp Encode,然后直接http返回</span></div><div class="line">                TC_HttpResponse httpResp;</div><div class="line">                httpResp.setContentType(<span class="string">"application/octet-stream;charset=UTF-8"</span>);</div><div class="line">                httpResp.setCacheControl(<span class="string">"no-cache"</span>);</div><div class="line">                httpResp.setResponse(<span class="number">200</span>, <span class="string">"OK"</span>, body);</div><div class="line">                body = httpResp.encode();</div><div class="line">                <span class="keyword">if</span>( !current-&gt;isResponse())</div><div class="line">                &#123;</div><div class="line">                    current-&gt;sendResponse(body.data(),body.size());</div><div class="line">                    FDLOG(<span class="string">"protocol"</span>)&lt;&lt; requestName&lt;&lt; <span class="string">"|REQ|"</span> &lt;&lt; m_ossReq.str() &lt;&lt;</div><div class="line">                        <span class="string">"|RSP|"</span> &lt;&lt; ossRsp.str() &lt;&lt; <span class="string">"|"</span>&lt;&lt; ret &lt;&lt;<span class="string">"|"</span>&lt;&lt; getCostInMS() &lt;&lt; <span class="string">"|"</span> &lt;&lt; body.size() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TFORWARDFOR, <span class="keyword">typename</span> TF, <span class="keyword">typename</span> TCONTEXT&gt;</div><div class="line">            <span class="function"><span class="keyword">static</span> TF* <span class="title">makeCallback</span><span class="params">(<span class="keyword">const</span> TCONTEXT&amp; context, <span class="keyword">const</span> TREQS&amp;... treqs)</span> </span>&#123;</div><div class="line">                <span class="comment">//为了避免多次填写模板参数,方便生成callback对象,所以使用了一个独立的静态工厂函数,实现模板参数的推导</span></div><div class="line">                <span class="keyword">auto</span> pThis = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">typename</span> HTTPForward&lt;TREQS...&gt;::<span class="keyword">template</span> Return&lt;TR&gt;::<span class="keyword">template</span> MultiReqRspGenericHttpProcesser&lt;TRSPS...&gt;&gt;();</div><div class="line">                TF* base = <span class="keyword">new</span> <span class="keyword">typename</span> TFORWARDFOR::<span class="keyword">template</span> Forward&lt;TREQS...&gt;::<span class="keyword">template</span> Return&lt;TR&gt;::<span class="keyword">template</span> Callback&lt;TF, TCONTEXT, TRSPS...&gt;(</div><div class="line">                    <span class="built_in">std</span>::dynamic_pointer_cast&lt;<span class="keyword">typename</span> ForwardHelper::Forward&lt;TREQS...&gt;::<span class="keyword">template</span> Return&lt;TR&gt;::<span class="keyword">template</span> CallbackProcesserBase&lt;TCONTEXT, TRSPS...&gt;&gt;(pThis),</div><div class="line">                    context,</div><div class="line">                    treqs...);</div><div class="line">                <span class="keyword">return</span> base;</div><div class="line">            &#125;</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">            <span class="keyword">int64_t</span> m_startTime;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">ostringstream</span> m_ossReq;</div><div class="line">            <span class="keyword">int64_t</span> getCostInMS() <span class="keyword">const</span> &#123;</div><div class="line">                <span class="keyword">return</span> TNOWMS - m_startTime;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>最后,通过变参模板,我实现了一个接口只需要两行代码即可进行转发,一行代码是使用DEFINE_FORWARD_CALLBACK 宏生成一个callback的基类, 一行代码是用来表示这个接口的返回值,入参和出参,代码长相如下:</p><p>CASE宏定义,简化最终代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CASE</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CASE(exp)                               \</span></div><div class="line">    &#123;                                           \</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>) &#123;                              \</div><div class="line">            <span class="keyword">return</span> ret;                         \</div><div class="line">        &#125;                                       \</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p><p>定义一个接口的转发代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CASE((Dispatcher&lt;FakeServerPrx::Callback, GET_FORWARDER(fakeRequestName), tars::TarsCurrentPtr&gt;</div><div class="line">::REQ&lt;<span class="keyword">int64_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;   <span class="comment">//入参列表,支持0-N个任意类型的参数</span></div><div class="line">::RSP&lt;<span class="keyword">const</span> FakeResponse2&amp;, <span class="keyword">const</span> FakeResponse&amp;&gt;  <span class="comment">//出参列表,0-N个任意类型的回包</span></div><div class="line">::tryDispatch(current, iterPrx-&gt;second, req.header.funcName, GETSTR(getProfile), req.params)));</div></pre></td></tr></table></figure></p><p>Dispatcher 的主要逻辑是把一个std::vector<std::string>的请求参数列表解包成其对应类型的Tars结构体,然后日志记录并且向下进行转发,也使用了变参模板的特性.这里就不赘述了.</std::string></p><p>后面,我们可以根据.tars文件定义的RPC接口,来动态生成转发代码,从而实现Proxy服务全自动生成.对外暴露接口再也没有任何工作量了!</p><h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><ul><li>我觉得写代码的一大乐趣,就是把复杂的问题简单化,复杂的事情只做一次.尽可能的减少对外暴露的复杂度,就本例来说,基本上算是做到了.</li><li>以上代码使用了变参模板的递归,和tuple递归,这里的思想其实是和erlang这种函数式语言的for循环一样,使用这种看似很奇怪的写法,是因为模板里面<em>没有变量,只有常量</em>.</li><li>Dispatcher中使用了把变参模板暂存为一个tuple,然后再unpacking, 需要使用另一个函数来中转, 这种写法还是很奇怪,很hacking, 不过似乎也没有其他的写法了.参考<a href="https://www.murrayc.com/permalink/2015/12/05/modern-c-variadic-template-parameters-and-tuples/" target="_blank" rel="external">这里</a>.</li><li>核心思想是:<ol><li>把各种类型的Callback通过宏自动生成</li><li>找一个地方汇总所有的Callback的结果然后统一处理</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Fantastic&quot;&gt;&lt;a href=&quot;#Fantastic&quot; class=&quot;headerlink&quot; title=&quot;Fantastic&quot;&gt;&lt;/a&gt;Fantastic&lt;/h1&gt;&lt;p&gt;C++14有很多新特性,但是最让人着迷的,莫过于变参模板了,变参模板把函数式的编程思
      
    
    </summary>
    
    
      <category term="cpp14" scheme="http://lida.site/tags/cpp14/"/>
    
      <category term="cpp" scheme="http://lida.site/tags/cpp/"/>
    
      <category term="tars" scheme="http://lida.site/tags/tars/"/>
    
      <category term="proxy" scheme="http://lida.site/tags/proxy/"/>
    
      <category term="template" scheme="http://lida.site/tags/template/"/>
    
      <category term="variadic template" scheme="http://lida.site/tags/variadic-template/"/>
    
  </entry>
  
  <entry>
    <title>使用tcpdump抓包并通过wireshark图形化工具来分析网络问题</title>
    <link href="http://lida.site/2017/09/28/%E4%BD%BF%E7%94%A8tcpdump%E6%8A%93%E5%8C%85%E5%B9%B6%E9%80%9A%E8%BF%87wireshark%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7%E6%9D%A5%E5%88%86%E6%9E%90%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
    <id>http://lida.site/2017/09/28/使用tcpdump抓包并通过wireshark图形化工具来分析网络问题/</id>
    <published>2017-09-28T06:03:38.000Z</published>
    <updated>2017-09-28T08:12:31.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>最近后台告警信息比较多, 大概看了一下, 发现一些很正常的请求偶尔会有几百毫秒甚至一两秒的耗时. 分析了一下代码, 应该不是代码的问题, 于是在mysql创建连接处加了一个耗时统计, 果然, 罪魁祸首就是创建mysql连接导致的.</p><h1 id="编写test重现问题"><a href="#编写test重现问题" class="headerlink" title="编写test重现问题"></a>编写test重现问题</h1><p>为了确认是否是单纯的创建mysql连接导致,而不是其他的因素影响,我单独写了一个 shell 脚本, 不停的创建连接,然后统计耗时,一旦超过预设值100ms就打印告警信息并停下来. 执行脚本,果然与预想中的一样,创建了几千个连接后,就出现了一个耗时特别长的请求.</p><p>先使用tcpdump开始抓包,然后执行脚本.<br>因为测试脚本的逻辑是一旦发现耗时过长的连接,马上停止执行,所以针对端口进行抓包,最后几个包一定是有问题的.</p><p>脚本代码如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line"><span class="meta">#</span> arg1=start, arg2=end, format: %s.%N</div><div class="line">function getTiming() &#123;</div><div class="line">    start=$1</div><div class="line">    end=$2</div><div class="line"></div><div class="line">    start_s=$(echo $start | cut -d '.' -f 1)</div><div class="line">    start_ns=$(echo $start | cut -d '.' -f 2)</div><div class="line">    end_s=$(echo $end | cut -d '.' -f 1)</div><div class="line">    end_ns=$(echo $end | cut -d '.' -f 2)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#</span> for debug..</div><div class="line"><span class="meta">#</span>    echo $start</div><div class="line"><span class="meta">#</span>    echo $end</div><div class="line"></div><div class="line"></div><div class="line">    time=$(( ( 10#$end_s - 10#$start_s ) * 1000 + ( 10#$end_ns / 1000000 - 10#$start_ns / 1000000 ) ))</div><div class="line"></div><div class="line"></div><div class="line">echo $time</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">for a in $(seq 1 10000)</div><div class="line">do</div><div class="line">start=$(date +%s.%N)</div><div class="line">/usr/bin/mysql -utest -p123456  -h 192.168.0.11 -Dtestdb -e "quit" &gt; /dev/null 2&amp;&gt;1</div><div class="line">end=$(date +%s.%N)</div><div class="line">elapsed=`getTiming $start $end`</div><div class="line">if [ $elapsed -gt 100 ]</div><div class="line">then</div><div class="line">echo $start "elapsed:" $elapsed</div><div class="line">exit</div><div class="line">fi</div><div class="line">done</div></pre></td></tr></table></figure><p>抓包命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo tcpdump -i any -s 0 -w /var/tmp/1.cap port 3306</div></pre></td></tr></table></figure><p>抓到包后发现,很难找到真正耗时的那个请求,因为创建的连接数太多了,而每一个请求并没有表示耗时的属性,只能通过肉眼观察一个回报和其对应的请求之间相隔多久来得出耗时. 而且不知道为什么, 脚本中的这一行代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/mysql -utest -p123456  -h 192.168.0.11 -Dtestdb -e "quit" &gt; /dev/null 2&amp;&gt;1</div></pre></td></tr></table></figure><p>在抓包信息中显示,找不到db 2 这个库. -e “quit” 会导致这个错误,也不知怎么回事.</p><p>最后想到一个办法,直接使用C++写客户端,虽然麻烦一点,但是可以知道出问题的连接的端口号,这样就可以精确查找这个端口号的所有收发包了.同时也可以精确的计算一个连接创建的耗时而不是像脚本里面那样,计算了创建的耗时加上断开的耗时.</p><h1 id="使用C-编写测试客户端"><a href="#使用C-编写测试客户端" class="headerlink" title="使用C++编写测试客户端"></a>使用C++编写测试客户端</h1><p>以下代码使用了google test 框架 和 mysql c driver</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">100000</span>; ++i) &#123;</div><div class="line">  <span class="keyword">auto</span> now = TNOWMS;</div><div class="line">  <span class="keyword">auto</span> _pstMql = mysql_init(<span class="literal">NULL</span>);</div><div class="line">  <span class="keyword">auto</span> elapsed_mysql_init = TNOWMS - now;</div><div class="line">  <span class="keyword">auto</span> now1 = TNOWMS;</div><div class="line">  <span class="comment">//建立连接后, 自动调用设置字符集语句</span></div><div class="line">  <span class="keyword">if</span> (mysql_options(_pstMql, MYSQL_SET_CHARSET_NAME, <span class="string">"utf8"</span>)) &#123;</div><div class="line">    <span class="keyword">throw</span> TC_Mysql_Exception(<span class="built_in">string</span>(<span class="string">"TC_Mysql::connect: mysql_options MYSQL_SET_CHARSET_NAME "</span>) + <span class="string">"utf8"</span> + <span class="string">":"</span> + <span class="built_in">string</span>(mysql_error(_pstMql)));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">auto</span> elapsed_options = TNOWMS - now1;</div><div class="line">  <span class="keyword">auto</span> now2 = TNOWMS;</div><div class="line">  <span class="keyword">if</span> (mysql_real_connect(_pstMql, <span class="string">"192.168.0.11"</span>, <span class="string">"test"</span>, <span class="string">"123456"</span>, <span class="literal">NULL</span>, (<span class="keyword">int</span>)<span class="number">3306</span>, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> TC_Mysql_Exception(<span class="string">"[TC_Mysql::connect]: mysql_real_connect: "</span> + <span class="built_in">string</span>(mysql_error(_pstMql)));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">auto</span> elapsed_conn = TNOWMS - now2;</div><div class="line">  <span class="keyword">auto</span> elapsed = TNOWMS - now;</div><div class="line">  <span class="keyword">if</span> (elapsed &gt; <span class="number">500</span>) &#123;  <span class="comment">//如果创建连接耗时500以上</span></div><div class="line">    <span class="keyword">auto</span> localIpPort = getIPHostBySocketFD(_pstMql-&gt;net.fd, <span class="literal">true</span>);  <span class="comment">//获取当前连接的local port和peer port</span></div><div class="line">    <span class="keyword">auto</span> peerIpPort = getIPHostBySocketFD(_pstMql-&gt;net.fd, <span class="literal">false</span>);</div><div class="line">    DEBUGLOG &lt;&lt; <span class="string">"local|"</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(localIpPort) &lt;&lt; <span class="string">"|"</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(localIpPort) &lt;&lt; <span class="string">"|peer|"</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(peerIpPort) &lt;&lt; <span class="string">"|"</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(peerIpPort) &lt;&lt; <span class="string">"|mysql_init|"</span> &lt;&lt; elapsed_mysql_init &lt;&lt; <span class="string">"|elapsed_options|"</span> &lt;&lt; elapsed_options &lt;&lt; <span class="string">"|elapsed_connect|"</span> &lt;&lt; elapsed_conn &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">  ASSERT_LT(elapsed, <span class="number">500</span>);</div><div class="line">  mysql_close(_pstMql);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>编译执行之后, 捕获到了一个端口号为 58818 连接耗时过高</p><img src="/2017/09/28/使用tcpdump抓包并通过wireshark图形化工具来分析网络问题/wireshark.png" alt="[wireshark]" title="[wireshark]"><p>通过以上截图中的时间可以看到, 主要是 Mysql协议的登录请求导致耗时过高.</p><p>接下来,就可以去查查Mysql登录的回包为啥会这么慢了.抓包这部分的工作就算是完成了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h1&gt;&lt;p&gt;最近后台告警信息比较多, 大概看了一下, 发现一些很正常的请求偶尔会有几百毫秒甚至一两秒的耗时. 分析了一下代码, 应该不是
      
    
    </summary>
    
    
      <category term="抓包" scheme="http://lida.site/tags/%E6%8A%93%E5%8C%85/"/>
    
      <category term="tcpdump" scheme="http://lida.site/tags/tcpdump/"/>
    
      <category term="wireshark" scheme="http://lida.site/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title>解决libmysqlclient在多线程环境下初始化会有几率crash的问题</title>
    <link href="http://lida.site/2017/08/31/how-to-fix-libmysqlclient-init-crash-in-multithreading-environment/"/>
    <id>http://lida.site/2017/08/31/how-to-fix-libmysqlclient-init-crash-in-multithreading-environment/</id>
    <published>2017-08-31T07:38:41.000Z</published>
    <updated>2017-08-31T08:03:03.473Z</updated>
    
    <content type="html"><![CDATA[<p>这个问题在<a href="/2017/08/28/fix-mysql-c-connector-driver-crash-on-mysql-options-with-multithreading/" title="之前的一篇文章">之前的一篇文章</a>中提到过,通过更换libmysqlclient的版本暂时规避了这个问题,但是后面使用过程中发现,其实还是不对的,启动时mysql_init有几率会返回一个空指针,后面的逻辑就走不下去了.所以怀疑这个问题其实和库的版本无关, 换了个库版本只是让问题的表现形式不同了而已.</p><p>上mysql官网继续查阅文档,发现一篇文档如下:</p><blockquote><p><a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-init.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.7/en/mysql-init.html</a><br>In a nonmulti-threaded environment, mysql_init() invokes mysql_library_init() automatically as necessary. However, mysql_library_init() is not thread-safe in a multi-threaded environment, and thus neither is mysql_init(). Before calling mysql_init(), either call mysql_library_init() prior to spawning any threads, or use a mutex to protect the mysql_library_init() call. This should be done prior to any other client library call.</p></blockquote><p>大概意思是 mysql_init 会检查 mysql_library_init这个函数是否有调用过,如果没调用过就会去调用一次, 而mysql_library_init这个函数不是线程安全的,所以导致mysql_init 也不是线程安全的, 所以需要在调用libmysqlclient 库里面的任何一个函数之前调用mysql_library_init, 用面向对象的思想来理解,就类似于单例模式的主动初始化.</p><p>为了验证问题是否被解决,我写了如下测试代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dbname = <span class="string">"testdb"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> ip = <span class="string">"192.168.0.1"</span>;</div><div class="line"><span class="keyword">int</span> port = <span class="number">3306</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> username = <span class="string">"testuser1"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> password = <span class="string">"asdfgh"</span>;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::thread&gt;&gt; threads;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i != <span class="number">100</span>; ++i) &#123;</div><div class="line">  <span class="keyword">auto</span> pThread = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::thread&gt;([&amp;]()&#123;</div><div class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TC_Mysql&gt; pMysqlConn(<span class="keyword">new</span> TC_Mysql(ip, username, password, dbname, <span class="string">"utf8"</span>, port));</div><div class="line">      pMysqlConn-&gt;connect();</div><div class="line">      DEBUGLOG &lt;&lt; <span class="string">"mysql connected"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;);</div><div class="line">  threads.emplace_back(pThread);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pT : threads) &#123;</div><div class="line">  pT-&gt;join();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码开启了100个线程,每个线程内只做一件事,就是创建一个mysql连接并连接到mysql服务器.</p><p>毫无悬念的,直接执行会导致crash.</p><p>现在,把他修改一下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dbname = <span class="string">"testdb"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> ip = <span class="string">"192.168.0.1"</span>;</div><div class="line"><span class="keyword">int</span> port = <span class="number">3306</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> username = <span class="string">"testuser1"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> password = <span class="string">"asdfgh"</span>;</div><div class="line">mysql_library_init(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);  <span class="comment">//这里增加了一行libmysqlclient库初始化代码</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::thread&gt;&gt; threads;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i != <span class="number">100</span>; ++i) &#123;</div><div class="line">  <span class="keyword">auto</span> pThread = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::thread&gt;([&amp;]()&#123;</div><div class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TC_Mysql&gt; pMysqlConn(<span class="keyword">new</span> TC_Mysql(ip, username, password, dbname, <span class="string">"utf8"</span>, port));</div><div class="line">      pMysqlConn-&gt;connect();</div><div class="line">      DEBUGLOG &lt;&lt; <span class="string">"mysql connected"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;);</div><div class="line">  threads.emplace_back(pThread);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pT : threads) &#123;</div><div class="line">  pT-&gt;join();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在创建连接之前调用  mysql_library_init 函数,编译运行后发现可以成功创建连接,程序不会crash.</p><p>至此这个问题算是最终解决了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个问题在&lt;a href=&quot;/2017/08/28/fix-mysql-c-connector-driver-crash-on-mysql-options-with-multithreading/&quot; title=&quot;之前的一篇文章&quot;&gt;之前的一篇文章&lt;/a&gt;中提到过,通过更换l
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="http://lida.site/tags/ubuntu/"/>
    
      <category term="mysql" scheme="http://lida.site/tags/mysql/"/>
    
      <category term="crash" scheme="http://lida.site/tags/crash/"/>
    
      <category term="libmysqlclient" scheme="http://lida.site/tags/libmysqlclient/"/>
    
      <category term="随笔" scheme="http://lida.site/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>找到某个命令依赖的软件包名称</title>
    <link href="http://lida.site/2017/08/28/how-to-find-a-command-depends-of/"/>
    <id>http://lida.site/2017/08/28/how-to-find-a-command-depends-of/</id>
    <published>2017-08-28T09:39:20.000Z</published>
    <updated>2017-08-28T09:41:33.541Z</updated>
    
    <content type="html"><![CDATA[<p>前两天需要使用mkpasswd这个命令用来加密密码,发现ubuntu16.04似乎没有自带这个命令, 直接apt-get install mkpasswd显示找不到任何软件包.就在想如果有个命令可以反向查找软件包名称就好了,google了一下果然有, 在这里记录一下,以免遗忘.</p><p>Ubuntu:</p><blockquote><p>$apt-get install apt-file<br>$apt-file update<br>$apt-file search<br>$apt-file search mkpasswd</p></blockquote><p>CentOS:</p><blockquote><p>yum whatprovides commandName</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两天需要使用mkpasswd这个命令用来加密密码,发现ubuntu16.04似乎没有自带这个命令, 直接apt-get install mkpasswd显示找不到任何软件包.就在想如果有个命令可以反向查找软件包名称就好了,google了一下果然有, 在这里记录一下,以免遗
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="http://lida.site/tags/ubuntu/"/>
    
      <category term="apt-get" scheme="http://lida.site/tags/apt-get/"/>
    
      <category term="linux" scheme="http://lida.site/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>解决libmysqlclient 在多线程下调用mysql_options 函数出现Segmentation fault的问题</title>
    <link href="http://lida.site/2017/08/28/fix-mysql-c-connector-driver-crash-on-mysql-options-with-multithreading/"/>
    <id>http://lida.site/2017/08/28/fix-mysql-c-connector-driver-crash-on-mysql-options-with-multithreading/</id>
    <published>2017-08-28T07:15:53.000Z</published>
    <updated>2017-08-31T08:04:35.703Z</updated>
    
    <content type="html"><![CDATA[<p>一个服务,临近发布时突然发现在启动时会core dump, 通过调低线程数可以解决, 仔细调试后发现程序在调用mysql_options时触发了Segmentation fault.<br>服务有多个线程,每个线程一个mysql 连接, 在每个线程调用所有mysql_* 函数之前先调用了mysql_init.</p><p>查阅了官方文档: <a href="https://dev.mysql.com/doc/refman/5.7/en/c-api-threaded-clients.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.7/en/c-api-threaded-clients.html</a> 按照这个多线程编程指引,我的程序并没有问题.</p><p>查询自己的mysql库 的版本号,是 ubuntu16.04 软件库默认的版本:</p><blockquote><p>$ dpkg -l | grep mysqlclient<br>ii  libmysqlclient-dev                        5.7.19-0ubuntu0.16.04.1   amd64                     MySQL database development files<br>ii  libmysqlclient20:amd64                    5.7.19-0ubuntu0.16.04.1   amd64                     MySQL database client library</p></blockquote><p>怀疑是不是这个版本的库有bug, 上google查了一下没找到什么资料.于是自己动手,丰衣足食,上mysql官网下载了一个最新的c_connector 替换掉之前的库,开200个线程测试,一切ok.</p><p>下载连接:</p><blockquote><p><a href="https://cdn.mysql.com//Downloads/Connector-C/mysql-connector-c-6.1.11-linux-glibc2.12-x86_64.tar.gz" target="_blank" rel="external">https://cdn.mysql.com//Downloads/Connector-C/mysql-connector-c-6.1.11-linux-glibc2.12-x86_64.tar.gz</a></p></blockquote><p>没想到作为LTS版本的ubuntu官方软件库提供的库会有这么严重的bug, 看样子以后所有的库要尽量用官方发布的版本.</p><p>2017-08-31 增加:<br>后面发现通过更换libmysqlclient版本并不能解决问题,只是让问题的表现形式变得不同了, 彻底解决这个问题请看<a href="/2017/08/31/how-to-fix-libmysqlclient-init-crash-in-multithreading-environment/" title="这里">这里</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个服务,临近发布时突然发现在启动时会core dump, 通过调低线程数可以解决, 仔细调试后发现程序在调用mysql_options时触发了Segmentation fault.&lt;br&gt;服务有多个线程,每个线程一个mysql 连接, 在每个线程调用所有mysql_* 函
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="http://lida.site/tags/ubuntu/"/>
    
      <category term="mysql" scheme="http://lida.site/tags/mysql/"/>
    
      <category term="crash" scheme="http://lida.site/tags/crash/"/>
    
      <category term="libmysqlclient" scheme="http://lida.site/tags/libmysqlclient/"/>
    
      <category term="随笔" scheme="http://lida.site/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>在ubuntu上安装source-code-pro字体</title>
    <link href="http://lida.site/2017/08/25/how-to-install-adobe-source-code-pro-in-ubuntu/"/>
    <id>http://lida.site/2017/08/25/how-to-install-adobe-source-code-pro-in-ubuntu/</id>
    <published>2017-08-25T01:36:40.000Z</published>
    <updated>2017-08-28T07:27:43.479Z</updated>
    
    <content type="html"><![CDATA[<p>只需要两行命令,记录一下</p><blockquote><p>sudo git clone <a href="https://github.com/adobe-fonts/source-code-pro.git" target="_blank" rel="external">https://github.com/adobe-fonts/source-code-pro.git</a> /usr/share/fonts/opentype/scp<br>cd /usr/share/fonts/opentype/scp<br>sudo git checkout release   //很重要,直接使用master编译字体后可能会导致乱码<br>sudo fc-cache -f -v</p></blockquote><p>如果 /usr/share/fonts/opentype/ 文件夹不存在,可以 sudo mkdir -p /usr/share/fonts/opentype/ 创建</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;只需要两行命令,记录一下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo git clone &lt;a href=&quot;https://github.com/adobe-fonts/source-code-pro.git&quot; target=&quot;_blank&quot; rel=&quot;externa
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="http://lida.site/tags/ubuntu/"/>
    
      <category term="linux" scheme="http://lida.site/tags/linux/"/>
    
      <category term="随笔" scheme="http://lida.site/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="字体" scheme="http://lida.site/tags/%E5%AD%97%E4%BD%93/"/>
    
      <category term="fc-cache" scheme="http://lida.site/tags/fc-cache/"/>
    
  </entry>
  
  <entry>
    <title>在emacs中跳转光标到之前所在位置的几个方法</title>
    <link href="http://lida.site/2017/08/22/how-to-jump-to-previous-position-in-emacs/"/>
    <id>http://lida.site/2017/08/22/how-to-jump-to-previous-position-in-emacs/</id>
    <published>2017-08-22T09:18:11.000Z</published>
    <updated>2017-08-25T03:30:48.874Z</updated>
    
    <content type="html"><![CDATA[<p>仔细找了一下,有几个命令可以提供类似的功能:</p><blockquote><p>pop-global-mark C-x C-SPC</p></blockquote><p>这个命令提供了全局跳转到光标之前所在位置的功能,实际上这里也会有一个光标位置的list, 我安装了helm插件,所以有命令helm-global-mark-ring可以查看当前保存了哪些位置,这些位置信息就是一个环形队列, 使用pop-global-mark 来pop这个队列的最后一个元素,然后跳转过去.<br>试用后发现这个命令只有在显式使用C+SPC 进行 mark 操作并且马上切换到其他buffer时才会记录之前的位置, 而且同一个buffer记录的位置如果不pop掉,那么下次在同一个buffer内mark 其他位置也不会被放到global-mark-ring里面<br>用法比较奇怪.因为buffer之间的切换本来就很简单,C-x C-b 可以很方便的浏览所有的buffer并切换，切换buffer之前mark一下有点累赘了,所以个人感觉还是下一个命令适用范围比较广.</p><blockquote><p>C-u C-SPC</p></blockquote><p>这个命令会记录你的每次移动之前的位置,随便翻页,或者慢速上下移动光标,都会被记录,但是仅限当前buffer. 很多场景下也够用了, 如果安装了helm插件，可以通过helm-all-mark-rings来观察记录的位置</p><blockquote><p>helm-all-mark-rings</p></blockquote><p>这个命令可以很方便的查看当前所有的mark,当按快捷键得到的结果不符合预期时,可以再通过这个命令找到正确的跳转地址.</p><p>通过这三个命令应该可以更方便的在各种文件中jump了。</p><p>ps: 如果helm出现了两个结果列表(例如helm-all-mark-rings),可以使用C-o和M-o来切换列表, 前者表示next, 后者表示previous.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;仔细找了一下,有几个命令可以提供类似的功能:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pop-global-mark C-x C-SPC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个命令提供了全局跳转到光标之前所在位置的功能,实际上这里也会有一个光标位置的list, 我安
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://lida.site/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="emacs" scheme="http://lida.site/tags/emacs/"/>
    
      <category term="编辑器" scheme="http://lida.site/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="ide" scheme="http://lida.site/tags/ide/"/>
    
  </entry>
  
  <entry>
    <title>开了一个新的博客，在这里记录一些想法</title>
    <link href="http://lida.site/2017/08/22/new_blog_new_thought/"/>
    <id>http://lida.site/2017/08/22/new_blog_new_thought/</id>
    <published>2017-08-21T16:26:59.000Z</published>
    <updated>2017-08-22T06:37:07.999Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现vim的键位其实也挺好用的，工作时在线上环境不方便安装emacs以及他的一大堆插件，这时候vim就派上用场啦，所以熟悉vim的键位还是很重要的。<br>为了让自己的记忆成本最低，我觉得一定要抽空转spacemacs，尝试过两三次，还是没办法习惯。<br>因为我使用emacs比较重要的一个原因是eshell，可以很方便的操作光标进行各种复制粘贴操作，spaceemacs似乎对eshell不太友好。<br>spaceemacs的键位绑定也看得云里雾里的，还弄出了一个layer概念，不知道要怎么弄。<br>其实，我只需要把现在prelude 这一套的键位照搬到spacemacs应该就可以用得比较舒服了。得找时间试试看。<br>还有我自己的一些emacs私有配置因为换工作换电脑也弄丢了，挺可惜的。</p><p>emacs 用了这么久，总体来说挺方便，就是有一点不爽，缺少了回到光标之前所在的位置这个功能，几年前还在用vs的时候，这个功能可是相当好用啊，后来转linux，用了emacs后，似乎就没有用过这个功能了，曾经找了一阵子也没找到提供光标历史位置跳转的插件。所以现在我要先预测我下一步要跳到很远的地方，比如我现在的文件总共有1000行，我现在在500行，需要跳转到当前文件的某个函数，在第10行，那么我就只能C+x r spc a，来保存当前光标位置为a，然后再M+g g 10 到第10行，看完这个函数后再 C+x r j a 跳回去。太不方便了。<br>如果有插件可以根据光标停留的秒数来记录光标的位置，一个快捷键就可以回到光标的上一个位置，另一个快捷键前进到光标的下一个位置，类似于undo，redo。这样就方便多了。<br>我相信这么一个成熟的需求肯定有插件，只是我一直没找到。</p><p>有时间我再去找找，找到再回来发博客。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近发现vim的键位其实也挺好用的，工作时在线上环境不方便安装emacs以及他的一大堆插件，这时候vim就派上用场啦，所以熟悉vim的键位还是很重要的。&lt;br&gt;为了让自己的记忆成本最低，我觉得一定要抽空转spacemacs，尝试过两三次，还是没办法习惯。&lt;br&gt;因为我使用e
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://lida.site/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="emacs" scheme="http://lida.site/tags/emacs/"/>
    
      <category term="vim" scheme="http://lida.site/tags/vim/"/>
    
      <category term="编辑器" scheme="http://lida.site/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="ide" scheme="http://lida.site/tags/ide/"/>
    
  </entry>
  
</feed>
