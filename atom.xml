<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dream Creator&#39;s blog</title>
  
  <subtitle>一个爱做梦的人在这里自说自话</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lida.site/"/>
  <updated>2017-11-06T07:00:03.669Z</updated>
  <id>http://lida.site/</id>
  
  <author>
    <name>David Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过使用C++变参模板动态生成重载函数来解决Tars框架的消息转发问题</title>
    <link href="http://lida.site/2017/11/02/%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8C++%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E6%9D%A5%E8%A7%A3%E5%86%B3Tars%E6%A1%86%E6%9E%B6%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    <id>http://lida.site/2017/11/02/通过使用C++变参模板动态生成重载函数来解决Tars框架的消息转发问题/</id>
    <published>2017-11-02T02:38:12.000Z</published>
    <updated>2017-11-06T07:00:03.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fantastic"><a href="#Fantastic" class="headerlink" title="Fantastic"></a>Fantastic</h1><p>C++14有很多新特性,但是最让人着迷的,莫过于变参模板了,变参模板把函数式的编程思想在C++中发挥得淋漓尽致,让C++的灵活性提升了一个level,使用变参模板,可以写出看起来像是动态语言特性的代码.<br>最近遇到一个问题,如果没有变参模板,还真不知道该如何解决.</p><h1 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h1><p>我们的后台程序使用了Tars框架,他的IDL生成出来的C++代码中,有一个Callback类用来表示异步调用的回调,定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FakeCallbackBase</span> &#123;</span></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">callback_fakeRequestName</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">const</span> FakeResponse2 &amp;a1, <span class="keyword">const</span> FakeResponse&amp; a2)</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"no implement"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">callback_fakeRequestName_exception</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">const</span> FakeResponse2 &amp;a1, <span class="keyword">const</span> FakeResponse&amp; a2)</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"no implement"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>一眼看上去似乎也没什么问题,每个请求对应一个虚函数,要处理这个请求的callback,只需要重载对应的虚函数即可.<br>就处理业务逻辑来说,其实没啥太大问题.<br>但是,我现在要写的是一个Proxy,主要负责把内部的Tars接口使用开放的HTTP协议对外暴露,所以对每一个接口的业务逻辑都是一样的.我可不想把同一份代码不停的Copy &amp; Paste.<br>So… 我想到一个办法,变参模板!</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>分析上面的回调函数的定义,发现参数列表有如下规律:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">第一个参数是RPC的返回值,类似于函数的返回值,只有一个,后面的所有参数表示的是RPC的出参,是一个*可变列表*</div></pre></td></tr></table></figure><p>定义这样一个宏,方便用来给每一个RPC生成统一的Callback类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFINE_FORWARD_CALLBACK</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_FORWARD_CALLBACK(requestName) \</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForwardFor_</span>##<span class="title">requestName</span> &#123;</span>     \</div><div class="line"><span class="keyword">public</span>:                              \</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TREQS&gt; \</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Forward</span> &#123;</span> \</div><div class="line"><span class="keyword">public</span>: \</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TR&gt;\</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Return</span> &#123;</span>\</div><div class="line">        <span class="keyword">public</span>:\</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TF, <span class="keyword">typename</span> TCONTEXT, <span class="keyword">typename</span>... TRSPS&gt; \</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Callback</span> :</span> <span class="keyword">public</span> TF &#123;\</div><div class="line">        <span class="keyword">public</span>:                                                         \</div><div class="line">            Callback(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">typename</span> ForwardHelper::Forward&lt;TREQS...&gt;::<span class="keyword">template</span> Return&lt;TR&gt;::<span class="keyword">template</span> CallbackProcesserBase&lt;TCONTEXT, TRSPS...&gt;&gt; processer, <span class="keyword">const</span> TCONTEXT&amp; context, <span class="keyword">const</span> TREQS&amp;... tReqs) \</div><div class="line">            : m_processer(processer), m_context(context) &#123;                     \</div><div class="line">                m_processer-&gt;onRequest(m_context, <span class="built_in">std</span>::<span class="built_in">string</span>(#requestName), tReqs...); \</div><div class="line">            &#125;                                                           \</div><div class="line">            <span class="keyword">virtual</span> <span class="keyword">void</span> callback_##requestName(TR ret, TRSPS... rsps) &#123; \</div><div class="line">                m_processer-&gt;onCallback(m_context, <span class="built_in">std</span>::<span class="built_in">string</span>(#requestName), ret, rsps...); \</div><div class="line">            &#125;                                                           \</div><div class="line">            <span class="keyword">virtual</span> <span class="keyword">void</span> callback_##requestName##_exception(TR ret) &#123;\</div><div class="line">                m_processer-&gt;onCallbackException(m_context, <span class="built_in">std</span>::<span class="built_in">string</span>(#requestName), ret); \</div><div class="line">            &#125;\</div><div class="line">        <span class="keyword">private</span>:\</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">typename</span> ForwardHelper::Forward&lt;TREQS...&gt;::<span class="keyword">template</span> Return&lt;TR&gt;::<span class="keyword">template</span> CallbackProcesserBase&lt;TCONTEXT, TRSPS...&gt;&gt; m_processer; \</div><div class="line">            TCONTEXT m_context;                                         \</div><div class="line">        &#125;;\</div><div class="line">    <span class="keyword">private</span>:\</div><div class="line">        Return()&#123;&#125;\</div><div class="line">        Return(<span class="keyword">const</span> Return&amp;)&#123;&#125;\</div><div class="line">    &#125;;\</div><div class="line"><span class="keyword">private</span>:\</div><div class="line">    Forward()&#123;&#125;                                    \</div><div class="line">    Forward(<span class="keyword">const</span> ForwardFor_##requestName&amp;)&#123;&#125;                  \</div><div class="line">&#125;;                                                              \</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure><p>使用嵌套类是为了区分请求参数类型列表和回包(出参)参数类型列表<br>Forward类的模板参数是请求参数列表<br>Callback类的模板参数是回包参数列表<br>TCONTEXT是callback允许外带的一个上下文,方便发包和收包的逻辑衔接<br>TF是这个宏生成出来的类的基类,本例中就是上面出现的FakeCallbackBase<br>m_processer是用来统一处理所有回包的一个处理器,我们把<em>静态的代码转换为动态的代码</em>,靠的就是这个m_processer</p><p>下面来看一下Processer的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> ForwardHelper &#123;</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TREQS&gt;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Forward</span> &#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TR&gt;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Return</span> &#123;</span></div><div class="line">        <span class="keyword">public</span>:</div><div class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TCONTEXT, <span class="keyword">typename</span>... TRSPS&gt;</div><div class="line">            <span class="class"><span class="keyword">class</span> <span class="title">CallbackProcesserBase</span> &#123;</span></div><div class="line">            <span class="keyword">public</span>:</div><div class="line">                <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onRequest</span><span class="params">(TCONTEXT&amp; m_context, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; requestName, <span class="keyword">const</span> TREQS&amp;... tReqs)</span> </span>= <span class="number">0</span>;</div><div class="line">                <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onCallbackException</span><span class="params">(TCONTEXT&amp; m_context, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; requestName, TR t)</span> </span>= <span class="number">0</span>;</div><div class="line">                <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onCallback</span><span class="params">(TCONTEXT&amp; m_context, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; requestName, TR t, TRSPS... rsps)</span> </span>= <span class="number">0</span>;</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>CallbackProcesserBase 就是Processer的基类,因为我们要实现的是HTTP的转发,所以使用一个派生类来实现以上的接口定义,代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TREQS&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPForward</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TR&gt;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Return</span> &#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TRSPS&gt;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MultiReqRspGenericHttpProcesser</span> :</span> <span class="keyword">public</span> ForwardHelper::Forward&lt;TREQS...&gt;::<span class="keyword">template</span> Return&lt;TR&gt;::<span class="keyword">template</span> CallbackProcesserBase&lt;tars::TarsCurrentPtr, TRSPS...&gt; &#123;</div><div class="line">        <span class="keyword">public</span>:</div><div class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onRequest</span><span class="params">(tars::TarsCurrentPtr &amp;current, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; requestName, <span class="keyword">const</span> TREQS&amp;... tReqs)</span> </span>&#123;</div><div class="line">                m_startTime = TNOWMS;</div><div class="line">                getStringStreamByMultiParam(m_ossReq, tReqs...);</div><div class="line">                FDLOG(<span class="string">"protocol"</span>) &lt;&lt; requestName &lt;&lt; <span class="string">"|REQ|"</span> &lt;&lt; m_ossReq.str() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onCallbackException</span><span class="params">(tars::TarsCurrentPtr &amp;current, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; requestName, TR ret)</span> </span>&#123;</div><div class="line">                ERRORLOG &lt;&lt; requestName &lt;&lt; <span class="string">"|REQ|"</span> &lt;&lt; m_ossReq.str() &lt;&lt; <span class="string">"|"</span> &lt;&lt; ret &lt;&lt; <span class="string">"|"</span> &lt;&lt; getCostInMS() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">processCallback</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;bodies, <span class="built_in">std</span>::<span class="built_in">ostringstream</span> &amp;oss)</span> </span>&#123;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">processCallback</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;bodies, <span class="built_in">std</span>::<span class="built_in">ostringstream</span> &amp;oss, T lastOneOfRSPS)</span> </span>&#123;</div><div class="line">                bodies.emplace_back();</div><div class="line">                tarsEncode(lastOneOfRSPS, *bodies.rbegin());</div><div class="line">                oss &lt;&lt; lastOneOfRSPS;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... TRSPS2&gt;</div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">processCallback</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;bodies, <span class="built_in">std</span>::<span class="built_in">ostringstream</span> &amp;oss, T oneOfRSPS,  TRSPS2... rsps)</span> </span>&#123;</div><div class="line">                bodies.emplace_back();</div><div class="line">                tarsEncode(oneOfRSPS, *bodies.rbegin());</div><div class="line">                oss &lt;&lt; oneOfRSPS &lt;&lt; <span class="string">"|"</span>;</div><div class="line">                processCallback(bodies, oss, rsps...);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onCallback</span><span class="params">(tars::TarsCurrentPtr &amp;current, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; requestName, TR ret, TRSPS... rsps)</span> </span>&#123;</div><div class="line">                <span class="comment">//打包rsps, 然后使用current对proxy的调用方回包,从而实现统一的转发</span></div><div class="line">                <span class="built_in">std</span>::<span class="built_in">ostringstream</span> ossRsp;  <span class="comment">//日志使用</span></div><div class="line">                ResponseModern rsp;</div><div class="line">                processCallback(rsp.outParams, ossRsp, rsps...); <span class="comment">//这一行对rsps进行拆包,然后一个一个Encode到一个std::vector&lt;std::string&gt;(也就是rsp.outParams)中</span></div><div class="line">                rsp.result.retCode = ret;</div><div class="line">                <span class="built_in">string</span> body;</div><div class="line">                tarsEncode(rsp,body); <span class="comment">//最后把最外层的rsp Encode,然后直接http返回</span></div><div class="line">                TC_HttpResponse httpResp;</div><div class="line">                httpResp.setContentType(<span class="string">"application/octet-stream;charset=UTF-8"</span>);</div><div class="line">                httpResp.setCacheControl(<span class="string">"no-cache"</span>);</div><div class="line">                httpResp.setResponse(<span class="number">200</span>, <span class="string">"OK"</span>, body);</div><div class="line">                body = httpResp.encode();</div><div class="line">                <span class="keyword">if</span>( !current-&gt;isResponse())</div><div class="line">                &#123;</div><div class="line">                    current-&gt;sendResponse(body.data(),body.size());</div><div class="line">                    FDLOG(<span class="string">"protocol"</span>)&lt;&lt; requestName&lt;&lt; <span class="string">"|REQ|"</span> &lt;&lt; m_ossReq.str() &lt;&lt;</div><div class="line">                        <span class="string">"|RSP|"</span> &lt;&lt; ossRsp.str() &lt;&lt; <span class="string">"|"</span>&lt;&lt; ret &lt;&lt;<span class="string">"|"</span>&lt;&lt; getCostInMS() &lt;&lt; <span class="string">"|"</span> &lt;&lt; body.size() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TFORWARDFOR, <span class="keyword">typename</span> TF, <span class="keyword">typename</span> TCONTEXT&gt;</div><div class="line">            <span class="function"><span class="keyword">static</span> TF* <span class="title">makeCallback</span><span class="params">(<span class="keyword">const</span> TCONTEXT&amp; context, <span class="keyword">const</span> TREQS&amp;... treqs)</span> </span>&#123;</div><div class="line">                <span class="comment">//为了避免多次填写模板参数,方便生成callback对象,所以使用了一个独立的静态工厂函数,实现模板参数的推导</span></div><div class="line">                <span class="keyword">auto</span> pThis = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">typename</span> HTTPForward&lt;TREQS...&gt;::<span class="keyword">template</span> Return&lt;TR&gt;::<span class="keyword">template</span> MultiReqRspGenericHttpProcesser&lt;TRSPS...&gt;&gt;();</div><div class="line">                TF* base = <span class="keyword">new</span> <span class="keyword">typename</span> TFORWARDFOR::<span class="keyword">template</span> Forward&lt;TREQS...&gt;::<span class="keyword">template</span> Return&lt;TR&gt;::<span class="keyword">template</span> Callback&lt;TF, TCONTEXT, TRSPS...&gt;(</div><div class="line">                    <span class="built_in">std</span>::dynamic_pointer_cast&lt;<span class="keyword">typename</span> ForwardHelper::Forward&lt;TREQS...&gt;::<span class="keyword">template</span> Return&lt;TR&gt;::<span class="keyword">template</span> CallbackProcesserBase&lt;TCONTEXT, TRSPS...&gt;&gt;(pThis),</div><div class="line">                    context,</div><div class="line">                    treqs...);</div><div class="line">                <span class="keyword">return</span> base;</div><div class="line">            &#125;</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">            <span class="keyword">int64_t</span> m_startTime;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">ostringstream</span> m_ossReq;</div><div class="line">            <span class="keyword">int64_t</span> getCostInMS() <span class="keyword">const</span> &#123;</div><div class="line">                <span class="keyword">return</span> TNOWMS - m_startTime;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>最后,通过变参模板,我实现了一个接口只需要两行代码即可进行转发,一行代码是使用DEFINE_FORWARD_CALLBACK 宏生成一个callback的基类, 一行代码是用来表示这个接口的返回值,入参和出参,代码长相如下:</p><p>CASE宏定义,简化最终代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CASE</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CASE(exp)                               \</span></div><div class="line">    &#123;                                           \</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>) &#123;                              \</div><div class="line">            <span class="keyword">return</span> ret;                         \</div><div class="line">        &#125;                                       \</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p><p>定义一个接口的转发代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CASE((Dispatcher&lt;FakeServerPrx::Callback, GET_FORWARDER(fakeRequestName), tars::TarsCurrentPtr&gt;</div><div class="line">::REQ&lt;<span class="keyword">int64_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;   <span class="comment">//入参列表,支持0-N个任意类型的参数</span></div><div class="line">::RSP&lt;<span class="keyword">const</span> FakeResponse2&amp;, <span class="keyword">const</span> FakeResponse&amp;&gt;  <span class="comment">//出参列表,0-N个任意类型的回包</span></div><div class="line">::tryDispatch(current, iterPrx-&gt;second, req.header.funcName, GETSTR(getProfile), req.params)));</div></pre></td></tr></table></figure></p><p>Dispatcher 的主要逻辑是把一个std::vector<std::string>的请求参数列表解包成其对应类型的Tars结构体,然后日志记录并且向下进行转发,也使用了变参模板的特性.这里就不赘述了.</std::string></p><p>后面,我们可以根据.tars文件定义的RPC接口,来动态生成转发代码,从而实现Proxy服务全自动生成.对外暴露接口再也没有任何工作量了!</p><h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><ul><li>我觉得写代码的一大乐趣,就是把复杂的问题简单化,复杂的事情只做一次.尽可能的减少对外暴露的复杂度,就本例来说,基本上算是做到了.</li><li>以上代码使用了变参模板的递归,和tuple递归,这里的思想其实是和erlang这种函数式语言的for循环一样,使用这种看似很奇怪的写法,是因为模板里面<em>没有变量,只有常量</em>.</li><li>Dispatcher中使用了把变参模板暂存为一个tuple,然后再unpacking, 需要使用另一个函数来中转, 这种写法还是很奇怪,很hacking, 不过似乎也没有其他的写法了.参考<a href="https://www.murrayc.com/permalink/2015/12/05/modern-c-variadic-template-parameters-and-tuples/" target="_blank" rel="external">这里</a>.</li><li>核心思想是:<ol><li>把各种类型的Callback通过宏自动生成</li><li>找一个地方汇总所有的Callback的结果然后统一处理</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Fantastic&quot;&gt;&lt;a href=&quot;#Fantastic&quot; class=&quot;headerlink&quot; title=&quot;Fantastic&quot;&gt;&lt;/a&gt;Fantastic&lt;/h1&gt;&lt;p&gt;C++14有很多新特性,但是最让人着迷的,莫过于变参模板了,变参模板把函数式的编程思
      
    
    </summary>
    
    
      <category term="cpp" scheme="http://lida.site/tags/cpp/"/>
    
      <category term="tars" scheme="http://lida.site/tags/tars/"/>
    
      <category term="proxy" scheme="http://lida.site/tags/proxy/"/>
    
      <category term="template" scheme="http://lida.site/tags/template/"/>
    
      <category term="variadic template" scheme="http://lida.site/tags/variadic-template/"/>
    
      <category term="cpp14" scheme="http://lida.site/tags/cpp14/"/>
    
  </entry>
  
  <entry>
    <title>使用tcpdump抓包并通过wireshark图形化工具来分析网络问题</title>
    <link href="http://lida.site/2017/09/28/%E4%BD%BF%E7%94%A8tcpdump%E6%8A%93%E5%8C%85%E5%B9%B6%E9%80%9A%E8%BF%87wireshark%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7%E6%9D%A5%E5%88%86%E6%9E%90%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
    <id>http://lida.site/2017/09/28/使用tcpdump抓包并通过wireshark图形化工具来分析网络问题/</id>
    <published>2017-09-28T06:03:38.000Z</published>
    <updated>2017-09-28T08:12:31.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>最近后台告警信息比较多, 大概看了一下, 发现一些很正常的请求偶尔会有几百毫秒甚至一两秒的耗时. 分析了一下代码, 应该不是代码的问题, 于是在mysql创建连接处加了一个耗时统计, 果然, 罪魁祸首就是创建mysql连接导致的.</p><h1 id="编写test重现问题"><a href="#编写test重现问题" class="headerlink" title="编写test重现问题"></a>编写test重现问题</h1><p>为了确认是否是单纯的创建mysql连接导致,而不是其他的因素影响,我单独写了一个 shell 脚本, 不停的创建连接,然后统计耗时,一旦超过预设值100ms就打印告警信息并停下来. 执行脚本,果然与预想中的一样,创建了几千个连接后,就出现了一个耗时特别长的请求.</p><p>先使用tcpdump开始抓包,然后执行脚本.<br>因为测试脚本的逻辑是一旦发现耗时过长的连接,马上停止执行,所以针对端口进行抓包,最后几个包一定是有问题的.</p><p>脚本代码如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line"><span class="meta">#</span> arg1=start, arg2=end, format: %s.%N</div><div class="line">function getTiming() &#123;</div><div class="line">    start=$1</div><div class="line">    end=$2</div><div class="line"></div><div class="line">    start_s=$(echo $start | cut -d '.' -f 1)</div><div class="line">    start_ns=$(echo $start | cut -d '.' -f 2)</div><div class="line">    end_s=$(echo $end | cut -d '.' -f 1)</div><div class="line">    end_ns=$(echo $end | cut -d '.' -f 2)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#</span> for debug..</div><div class="line"><span class="meta">#</span>    echo $start</div><div class="line"><span class="meta">#</span>    echo $end</div><div class="line"></div><div class="line"></div><div class="line">    time=$(( ( 10#$end_s - 10#$start_s ) * 1000 + ( 10#$end_ns / 1000000 - 10#$start_ns / 1000000 ) ))</div><div class="line"></div><div class="line"></div><div class="line">echo $time</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">for a in $(seq 1 10000)</div><div class="line">do</div><div class="line">start=$(date +%s.%N)</div><div class="line">/usr/bin/mysql -utest -p123456  -h 192.168.0.11 -Dtestdb -e "quit" &gt; /dev/null 2&amp;&gt;1</div><div class="line">end=$(date +%s.%N)</div><div class="line">elapsed=`getTiming $start $end`</div><div class="line">if [ $elapsed -gt 100 ]</div><div class="line">then</div><div class="line">echo $start "elapsed:" $elapsed</div><div class="line">exit</div><div class="line">fi</div><div class="line">done</div></pre></td></tr></table></figure><p>抓包命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo tcpdump -i any -s 0 -w /var/tmp/1.cap port 3306</div></pre></td></tr></table></figure><p>抓到包后发现,很难找到真正耗时的那个请求,因为创建的连接数太多了,而每一个请求并没有表示耗时的属性,只能通过肉眼观察一个回报和其对应的请求之间相隔多久来得出耗时. 而且不知道为什么, 脚本中的这一行代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/mysql -utest -p123456  -h 192.168.0.11 -Dtestdb -e "quit" &gt; /dev/null 2&amp;&gt;1</div></pre></td></tr></table></figure><p>在抓包信息中显示,找不到db 2 这个库. -e “quit” 会导致这个错误,也不知怎么回事.</p><p>最后想到一个办法,直接使用C++写客户端,虽然麻烦一点,但是可以知道出问题的连接的端口号,这样就可以精确查找这个端口号的所有收发包了.同时也可以精确的计算一个连接创建的耗时而不是像脚本里面那样,计算了创建的耗时加上断开的耗时.</p><h1 id="使用C-编写测试客户端"><a href="#使用C-编写测试客户端" class="headerlink" title="使用C++编写测试客户端"></a>使用C++编写测试客户端</h1><p>以下代码使用了google test 框架 和 mysql c driver</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">100000</span>; ++i) &#123;</div><div class="line">  <span class="keyword">auto</span> now = TNOWMS;</div><div class="line">  <span class="keyword">auto</span> _pstMql = mysql_init(<span class="literal">NULL</span>);</div><div class="line">  <span class="keyword">auto</span> elapsed_mysql_init = TNOWMS - now;</div><div class="line">  <span class="keyword">auto</span> now1 = TNOWMS;</div><div class="line">  <span class="comment">//建立连接后, 自动调用设置字符集语句</span></div><div class="line">  <span class="keyword">if</span> (mysql_options(_pstMql, MYSQL_SET_CHARSET_NAME, <span class="string">"utf8"</span>)) &#123;</div><div class="line">    <span class="keyword">throw</span> TC_Mysql_Exception(<span class="built_in">string</span>(<span class="string">"TC_Mysql::connect: mysql_options MYSQL_SET_CHARSET_NAME "</span>) + <span class="string">"utf8"</span> + <span class="string">":"</span> + <span class="built_in">string</span>(mysql_error(_pstMql)));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">auto</span> elapsed_options = TNOWMS - now1;</div><div class="line">  <span class="keyword">auto</span> now2 = TNOWMS;</div><div class="line">  <span class="keyword">if</span> (mysql_real_connect(_pstMql, <span class="string">"192.168.0.11"</span>, <span class="string">"test"</span>, <span class="string">"123456"</span>, <span class="literal">NULL</span>, (<span class="keyword">int</span>)<span class="number">3306</span>, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> TC_Mysql_Exception(<span class="string">"[TC_Mysql::connect]: mysql_real_connect: "</span> + <span class="built_in">string</span>(mysql_error(_pstMql)));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">auto</span> elapsed_conn = TNOWMS - now2;</div><div class="line">  <span class="keyword">auto</span> elapsed = TNOWMS - now;</div><div class="line">  <span class="keyword">if</span> (elapsed &gt; <span class="number">500</span>) &#123;  <span class="comment">//如果创建连接耗时500以上</span></div><div class="line">    <span class="keyword">auto</span> localIpPort = getIPHostBySocketFD(_pstMql-&gt;net.fd, <span class="literal">true</span>);  <span class="comment">//获取当前连接的local port和peer port</span></div><div class="line">    <span class="keyword">auto</span> peerIpPort = getIPHostBySocketFD(_pstMql-&gt;net.fd, <span class="literal">false</span>);</div><div class="line">    DEBUGLOG &lt;&lt; <span class="string">"local|"</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(localIpPort) &lt;&lt; <span class="string">"|"</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(localIpPort) &lt;&lt; <span class="string">"|peer|"</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(peerIpPort) &lt;&lt; <span class="string">"|"</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(peerIpPort) &lt;&lt; <span class="string">"|mysql_init|"</span> &lt;&lt; elapsed_mysql_init &lt;&lt; <span class="string">"|elapsed_options|"</span> &lt;&lt; elapsed_options &lt;&lt; <span class="string">"|elapsed_connect|"</span> &lt;&lt; elapsed_conn &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">  ASSERT_LT(elapsed, <span class="number">500</span>);</div><div class="line">  mysql_close(_pstMql);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>编译执行之后, 捕获到了一个端口号为 58818 连接耗时过高</p><img src="/2017/09/28/使用tcpdump抓包并通过wireshark图形化工具来分析网络问题/wireshark.png" alt="[wireshark]" title="[wireshark]"><p>通过以上截图中的时间可以看到, 主要是 Mysql协议的登录请求导致耗时过高.</p><p>接下来,就可以去查查Mysql登录的回包为啥会这么慢了.抓包这部分的工作就算是完成了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h1&gt;&lt;p&gt;最近后台告警信息比较多, 大概看了一下, 发现一些很正常的请求偶尔会有几百毫秒甚至一两秒的耗时. 分析了一下代码, 应该不是
      
    
    </summary>
    
    
      <category term="抓包" scheme="http://lida.site/tags/%E6%8A%93%E5%8C%85/"/>
    
      <category term="tcpdump" scheme="http://lida.site/tags/tcpdump/"/>
    
      <category term="wireshark" scheme="http://lida.site/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title>解决libmysqlclient在多线程环境下初始化会有几率crash的问题</title>
    <link href="http://lida.site/2017/08/31/how-to-fix-libmysqlclient-init-crash-in-multithreading-environment/"/>
    <id>http://lida.site/2017/08/31/how-to-fix-libmysqlclient-init-crash-in-multithreading-environment/</id>
    <published>2017-08-31T07:38:41.000Z</published>
    <updated>2017-08-31T08:03:03.473Z</updated>
    
    <content type="html"><![CDATA[<p>这个问题在<a href="/2017/08/28/fix-mysql-c-connector-driver-crash-on-mysql-options-with-multithreading/" title="之前的一篇文章">之前的一篇文章</a>中提到过,通过更换libmysqlclient的版本暂时规避了这个问题,但是后面使用过程中发现,其实还是不对的,启动时mysql_init有几率会返回一个空指针,后面的逻辑就走不下去了.所以怀疑这个问题其实和库的版本无关, 换了个库版本只是让问题的表现形式不同了而已.</p><p>上mysql官网继续查阅文档,发现一篇文档如下:</p><blockquote><p><a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-init.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.7/en/mysql-init.html</a><br>In a nonmulti-threaded environment, mysql_init() invokes mysql_library_init() automatically as necessary. However, mysql_library_init() is not thread-safe in a multi-threaded environment, and thus neither is mysql_init(). Before calling mysql_init(), either call mysql_library_init() prior to spawning any threads, or use a mutex to protect the mysql_library_init() call. This should be done prior to any other client library call.</p></blockquote><p>大概意思是 mysql_init 会检查 mysql_library_init这个函数是否有调用过,如果没调用过就会去调用一次, 而mysql_library_init这个函数不是线程安全的,所以导致mysql_init 也不是线程安全的, 所以需要在调用libmysqlclient 库里面的任何一个函数之前调用mysql_library_init, 用面向对象的思想来理解,就类似于单例模式的主动初始化.</p><p>为了验证问题是否被解决,我写了如下测试代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dbname = <span class="string">"testdb"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> ip = <span class="string">"192.168.0.1"</span>;</div><div class="line"><span class="keyword">int</span> port = <span class="number">3306</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> username = <span class="string">"testuser1"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> password = <span class="string">"asdfgh"</span>;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::thread&gt;&gt; threads;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i != <span class="number">100</span>; ++i) &#123;</div><div class="line">  <span class="keyword">auto</span> pThread = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::thread&gt;([&amp;]()&#123;</div><div class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TC_Mysql&gt; pMysqlConn(<span class="keyword">new</span> TC_Mysql(ip, username, password, dbname, <span class="string">"utf8"</span>, port));</div><div class="line">      pMysqlConn-&gt;connect();</div><div class="line">      DEBUGLOG &lt;&lt; <span class="string">"mysql connected"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;);</div><div class="line">  threads.emplace_back(pThread);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pT : threads) &#123;</div><div class="line">  pT-&gt;join();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码开启了100个线程,每个线程内只做一件事,就是创建一个mysql连接并连接到mysql服务器.</p><p>毫无悬念的,直接执行会导致crash.</p><p>现在,把他修改一下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dbname = <span class="string">"testdb"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> ip = <span class="string">"192.168.0.1"</span>;</div><div class="line"><span class="keyword">int</span> port = <span class="number">3306</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> username = <span class="string">"testuser1"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> password = <span class="string">"asdfgh"</span>;</div><div class="line">mysql_library_init(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);  <span class="comment">//这里增加了一行libmysqlclient库初始化代码</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::thread&gt;&gt; threads;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i != <span class="number">100</span>; ++i) &#123;</div><div class="line">  <span class="keyword">auto</span> pThread = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::thread&gt;([&amp;]()&#123;</div><div class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TC_Mysql&gt; pMysqlConn(<span class="keyword">new</span> TC_Mysql(ip, username, password, dbname, <span class="string">"utf8"</span>, port));</div><div class="line">      pMysqlConn-&gt;connect();</div><div class="line">      DEBUGLOG &lt;&lt; <span class="string">"mysql connected"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;);</div><div class="line">  threads.emplace_back(pThread);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pT : threads) &#123;</div><div class="line">  pT-&gt;join();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在创建连接之前调用  mysql_library_init 函数,编译运行后发现可以成功创建连接,程序不会crash.</p><p>至此这个问题算是最终解决了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个问题在&lt;a href=&quot;/2017/08/28/fix-mysql-c-connector-driver-crash-on-mysql-options-with-multithreading/&quot; title=&quot;之前的一篇文章&quot;&gt;之前的一篇文章&lt;/a&gt;中提到过,通过更换l
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://lida.site/tags/mysql/"/>
    
      <category term="crash" scheme="http://lida.site/tags/crash/"/>
    
      <category term="libmysqlclient" scheme="http://lida.site/tags/libmysqlclient/"/>
    
      <category term="ubuntu" scheme="http://lida.site/tags/ubuntu/"/>
    
      <category term="随笔" scheme="http://lida.site/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>找到某个命令依赖的软件包名称</title>
    <link href="http://lida.site/2017/08/28/how-to-find-a-command-depends-of/"/>
    <id>http://lida.site/2017/08/28/how-to-find-a-command-depends-of/</id>
    <published>2017-08-28T09:39:20.000Z</published>
    <updated>2017-08-28T09:41:33.541Z</updated>
    
    <content type="html"><![CDATA[<p>前两天需要使用mkpasswd这个命令用来加密密码,发现ubuntu16.04似乎没有自带这个命令, 直接apt-get install mkpasswd显示找不到任何软件包.就在想如果有个命令可以反向查找软件包名称就好了,google了一下果然有, 在这里记录一下,以免遗忘.</p><p>Ubuntu:</p><blockquote><p>$apt-get install apt-file<br>$apt-file update<br>$apt-file search<br>$apt-file search mkpasswd</p></blockquote><p>CentOS:</p><blockquote><p>yum whatprovides commandName</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两天需要使用mkpasswd这个命令用来加密密码,发现ubuntu16.04似乎没有自带这个命令, 直接apt-get install mkpasswd显示找不到任何软件包.就在想如果有个命令可以反向查找软件包名称就好了,google了一下果然有, 在这里记录一下,以免遗
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="http://lida.site/tags/ubuntu/"/>
    
      <category term="linux" scheme="http://lida.site/tags/linux/"/>
    
      <category term="apt-get" scheme="http://lida.site/tags/apt-get/"/>
    
  </entry>
  
  <entry>
    <title>解决libmysqlclient 在多线程下调用mysql_options 函数出现Segmentation fault的问题</title>
    <link href="http://lida.site/2017/08/28/fix-mysql-c-connector-driver-crash-on-mysql-options-with-multithreading/"/>
    <id>http://lida.site/2017/08/28/fix-mysql-c-connector-driver-crash-on-mysql-options-with-multithreading/</id>
    <published>2017-08-28T07:15:53.000Z</published>
    <updated>2017-08-31T08:04:35.703Z</updated>
    
    <content type="html"><![CDATA[<p>一个服务,临近发布时突然发现在启动时会core dump, 通过调低线程数可以解决, 仔细调试后发现程序在调用mysql_options时触发了Segmentation fault.<br>服务有多个线程,每个线程一个mysql 连接, 在每个线程调用所有mysql_* 函数之前先调用了mysql_init.</p><p>查阅了官方文档: <a href="https://dev.mysql.com/doc/refman/5.7/en/c-api-threaded-clients.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.7/en/c-api-threaded-clients.html</a> 按照这个多线程编程指引,我的程序并没有问题.</p><p>查询自己的mysql库 的版本号,是 ubuntu16.04 软件库默认的版本:</p><blockquote><p>$ dpkg -l | grep mysqlclient<br>ii  libmysqlclient-dev                        5.7.19-0ubuntu0.16.04.1   amd64                     MySQL database development files<br>ii  libmysqlclient20:amd64                    5.7.19-0ubuntu0.16.04.1   amd64                     MySQL database client library</p></blockquote><p>怀疑是不是这个版本的库有bug, 上google查了一下没找到什么资料.于是自己动手,丰衣足食,上mysql官网下载了一个最新的c_connector 替换掉之前的库,开200个线程测试,一切ok.</p><p>下载连接:</p><blockquote><p><a href="https://cdn.mysql.com//Downloads/Connector-C/mysql-connector-c-6.1.11-linux-glibc2.12-x86_64.tar.gz" target="_blank" rel="external">https://cdn.mysql.com//Downloads/Connector-C/mysql-connector-c-6.1.11-linux-glibc2.12-x86_64.tar.gz</a></p></blockquote><p>没想到作为LTS版本的ubuntu官方软件库提供的库会有这么严重的bug, 看样子以后所有的库要尽量用官方发布的版本.</p><p>2017-08-31 增加:<br>后面发现通过更换libmysqlclient版本并不能解决问题,只是让问题的表现形式变得不同了, 彻底解决这个问题请看<a href="/2017/08/31/how-to-fix-libmysqlclient-init-crash-in-multithreading-environment/" title="这里">这里</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个服务,临近发布时突然发现在启动时会core dump, 通过调低线程数可以解决, 仔细调试后发现程序在调用mysql_options时触发了Segmentation fault.&lt;br&gt;服务有多个线程,每个线程一个mysql 连接, 在每个线程调用所有mysql_* 函
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://lida.site/tags/mysql/"/>
    
      <category term="crash" scheme="http://lida.site/tags/crash/"/>
    
      <category term="libmysqlclient" scheme="http://lida.site/tags/libmysqlclient/"/>
    
      <category term="ubuntu" scheme="http://lida.site/tags/ubuntu/"/>
    
      <category term="随笔" scheme="http://lida.site/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>在ubuntu上安装source-code-pro字体</title>
    <link href="http://lida.site/2017/08/25/how-to-install-adobe-source-code-pro-in-ubuntu/"/>
    <id>http://lida.site/2017/08/25/how-to-install-adobe-source-code-pro-in-ubuntu/</id>
    <published>2017-08-25T01:36:40.000Z</published>
    <updated>2017-08-28T07:27:43.478Z</updated>
    
    <content type="html"><![CDATA[<p>只需要两行命令,记录一下</p><blockquote><p>sudo git clone <a href="https://github.com/adobe-fonts/source-code-pro.git" target="_blank" rel="external">https://github.com/adobe-fonts/source-code-pro.git</a> /usr/share/fonts/opentype/scp<br>cd /usr/share/fonts/opentype/scp<br>sudo git checkout release   //很重要,直接使用master编译字体后可能会导致乱码<br>sudo fc-cache -f -v</p></blockquote><p>如果 /usr/share/fonts/opentype/ 文件夹不存在,可以 sudo mkdir -p /usr/share/fonts/opentype/ 创建</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;只需要两行命令,记录一下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo git clone &lt;a href=&quot;https://github.com/adobe-fonts/source-code-pro.git&quot; target=&quot;_blank&quot; rel=&quot;externa
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="http://lida.site/tags/ubuntu/"/>
    
      <category term="随笔" scheme="http://lida.site/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="字体" scheme="http://lida.site/tags/%E5%AD%97%E4%BD%93/"/>
    
      <category term="linux" scheme="http://lida.site/tags/linux/"/>
    
      <category term="fc-cache" scheme="http://lida.site/tags/fc-cache/"/>
    
  </entry>
  
  <entry>
    <title>在emacs中跳转光标到之前所在位置的几个方法</title>
    <link href="http://lida.site/2017/08/22/how-to-jump-to-previous-position-in-emacs/"/>
    <id>http://lida.site/2017/08/22/how-to-jump-to-previous-position-in-emacs/</id>
    <published>2017-08-22T09:18:11.000Z</published>
    <updated>2017-08-25T03:30:48.874Z</updated>
    
    <content type="html"><![CDATA[<p>仔细找了一下,有几个命令可以提供类似的功能:</p><blockquote><p>pop-global-mark C-x C-SPC</p></blockquote><p>这个命令提供了全局跳转到光标之前所在位置的功能,实际上这里也会有一个光标位置的list, 我安装了helm插件,所以有命令helm-global-mark-ring可以查看当前保存了哪些位置,这些位置信息就是一个环形队列, 使用pop-global-mark 来pop这个队列的最后一个元素,然后跳转过去.<br>试用后发现这个命令只有在显式使用C+SPC 进行 mark 操作并且马上切换到其他buffer时才会记录之前的位置, 而且同一个buffer记录的位置如果不pop掉,那么下次在同一个buffer内mark 其他位置也不会被放到global-mark-ring里面<br>用法比较奇怪.因为buffer之间的切换本来就很简单,C-x C-b 可以很方便的浏览所有的buffer并切换，切换buffer之前mark一下有点累赘了,所以个人感觉还是下一个命令适用范围比较广.</p><blockquote><p>C-u C-SPC</p></blockquote><p>这个命令会记录你的每次移动之前的位置,随便翻页,或者慢速上下移动光标,都会被记录,但是仅限当前buffer. 很多场景下也够用了, 如果安装了helm插件，可以通过helm-all-mark-rings来观察记录的位置</p><blockquote><p>helm-all-mark-rings</p></blockquote><p>这个命令可以很方便的查看当前所有的mark,当按快捷键得到的结果不符合预期时,可以再通过这个命令找到正确的跳转地址.</p><p>通过这三个命令应该可以更方便的在各种文件中jump了。</p><p>ps: 如果helm出现了两个结果列表(例如helm-all-mark-rings),可以使用C-o和M-o来切换列表, 前者表示next, 后者表示previous.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;仔细找了一下,有几个命令可以提供类似的功能:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pop-global-mark C-x C-SPC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个命令提供了全局跳转到光标之前所在位置的功能,实际上这里也会有一个光标位置的list, 我安
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://lida.site/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="emacs" scheme="http://lida.site/tags/emacs/"/>
    
      <category term="编辑器" scheme="http://lida.site/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="ide" scheme="http://lida.site/tags/ide/"/>
    
  </entry>
  
  <entry>
    <title>开了一个新的博客，在这里记录一些想法</title>
    <link href="http://lida.site/2017/08/22/new_blog_new_thought/"/>
    <id>http://lida.site/2017/08/22/new_blog_new_thought/</id>
    <published>2017-08-21T16:26:59.000Z</published>
    <updated>2017-08-22T06:37:07.998Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现vim的键位其实也挺好用的，工作时在线上环境不方便安装emacs以及他的一大堆插件，这时候vim就派上用场啦，所以熟悉vim的键位还是很重要的。<br>为了让自己的记忆成本最低，我觉得一定要抽空转spacemacs，尝试过两三次，还是没办法习惯。<br>因为我使用emacs比较重要的一个原因是eshell，可以很方便的操作光标进行各种复制粘贴操作，spaceemacs似乎对eshell不太友好。<br>spaceemacs的键位绑定也看得云里雾里的，还弄出了一个layer概念，不知道要怎么弄。<br>其实，我只需要把现在prelude 这一套的键位照搬到spacemacs应该就可以用得比较舒服了。得找时间试试看。<br>还有我自己的一些emacs私有配置因为换工作换电脑也弄丢了，挺可惜的。</p><p>emacs 用了这么久，总体来说挺方便，就是有一点不爽，缺少了回到光标之前所在的位置这个功能，几年前还在用vs的时候，这个功能可是相当好用啊，后来转linux，用了emacs后，似乎就没有用过这个功能了，曾经找了一阵子也没找到提供光标历史位置跳转的插件。所以现在我要先预测我下一步要跳到很远的地方，比如我现在的文件总共有1000行，我现在在500行，需要跳转到当前文件的某个函数，在第10行，那么我就只能C+x r spc a，来保存当前光标位置为a，然后再M+g g 10 到第10行，看完这个函数后再 C+x r j a 跳回去。太不方便了。<br>如果有插件可以根据光标停留的秒数来记录光标的位置，一个快捷键就可以回到光标的上一个位置，另一个快捷键前进到光标的下一个位置，类似于undo，redo。这样就方便多了。<br>我相信这么一个成熟的需求肯定有插件，只是我一直没找到。</p><p>有时间我再去找找，找到再回来发博客。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近发现vim的键位其实也挺好用的，工作时在线上环境不方便安装emacs以及他的一大堆插件，这时候vim就派上用场啦，所以熟悉vim的键位还是很重要的。&lt;br&gt;为了让自己的记忆成本最低，我觉得一定要抽空转spacemacs，尝试过两三次，还是没办法习惯。&lt;br&gt;因为我使用e
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://lida.site/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="emacs" scheme="http://lida.site/tags/emacs/"/>
    
      <category term="编辑器" scheme="http://lida.site/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="ide" scheme="http://lida.site/tags/ide/"/>
    
      <category term="vim" scheme="http://lida.site/tags/vim/"/>
    
  </entry>
  
</feed>
