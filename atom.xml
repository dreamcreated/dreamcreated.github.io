<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dream Creator&#39;s blog</title>
  
  <subtitle>一个爱做梦的人在这里自说自话</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lida.site/"/>
  <updated>2017-09-28T08:12:31.115Z</updated>
  <id>http://lida.site/</id>
  
  <author>
    <name>David Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用tcpdump抓包并通过wireshark图形化工具来分析网络问题</title>
    <link href="http://lida.site/2017/09/28/%E4%BD%BF%E7%94%A8tcpdump%E6%8A%93%E5%8C%85%E5%B9%B6%E9%80%9A%E8%BF%87wireshark%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7%E6%9D%A5%E5%88%86%E6%9E%90%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
    <id>http://lida.site/2017/09/28/使用tcpdump抓包并通过wireshark图形化工具来分析网络问题/</id>
    <published>2017-09-28T06:03:38.000Z</published>
    <updated>2017-09-28T08:12:31.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>最近后台告警信息比较多, 大概看了一下, 发现一些很正常的请求偶尔会有几百毫秒甚至一两秒的耗时. 分析了一下代码, 应该不是代码的问题, 于是在mysql创建连接处加了一个耗时统计, 果然, 罪魁祸首就是创建mysql连接导致的.</p><h1 id="编写test重现问题"><a href="#编写test重现问题" class="headerlink" title="编写test重现问题"></a>编写test重现问题</h1><p>为了确认是否是单纯的创建mysql连接导致,而不是其他的因素影响,我单独写了一个 shell 脚本, 不停的创建连接,然后统计耗时,一旦超过预设值100ms就打印告警信息并停下来. 执行脚本,果然与预想中的一样,创建了几千个连接后,就出现了一个耗时特别长的请求.</p><p>先使用tcpdump开始抓包,然后执行脚本.<br>因为测试脚本的逻辑是一旦发现耗时过长的连接,马上停止执行,所以针对端口进行抓包,最后几个包一定是有问题的.</p><p>脚本代码如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line"><span class="meta">#</span> arg1=start, arg2=end, format: %s.%N</div><div class="line">function getTiming() &#123;</div><div class="line">    start=$1</div><div class="line">    end=$2</div><div class="line"></div><div class="line">    start_s=$(echo $start | cut -d '.' -f 1)</div><div class="line">    start_ns=$(echo $start | cut -d '.' -f 2)</div><div class="line">    end_s=$(echo $end | cut -d '.' -f 1)</div><div class="line">    end_ns=$(echo $end | cut -d '.' -f 2)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#</span> for debug..</div><div class="line"><span class="meta">#</span>    echo $start</div><div class="line"><span class="meta">#</span>    echo $end</div><div class="line"></div><div class="line"></div><div class="line">    time=$(( ( 10#$end_s - 10#$start_s ) * 1000 + ( 10#$end_ns / 1000000 - 10#$start_ns / 1000000 ) ))</div><div class="line"></div><div class="line"></div><div class="line">echo $time</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">for a in $(seq 1 10000)</div><div class="line">do</div><div class="line">start=$(date +%s.%N)</div><div class="line">/usr/bin/mysql -utest -p123456  -h 192.168.0.11 -Dtestdb -e "quit" &gt; /dev/null 2&amp;&gt;1</div><div class="line">end=$(date +%s.%N)</div><div class="line">elapsed=`getTiming $start $end`</div><div class="line">if [ $elapsed -gt 100 ]</div><div class="line">then</div><div class="line">echo $start "elapsed:" $elapsed</div><div class="line">exit</div><div class="line">fi</div><div class="line">done</div></pre></td></tr></table></figure><p>抓包命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo tcpdump -i any -s 0 -w /var/tmp/1.cap port 3306</div></pre></td></tr></table></figure><p>抓到包后发现,很难找到真正耗时的那个请求,因为创建的连接数太多了,而每一个请求并没有表示耗时的属性,只能通过肉眼观察一个回报和其对应的请求之间相隔多久来得出耗时. 而且不知道为什么, 脚本中的这一行代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/mysql -utest -p123456  -h 192.168.0.11 -Dtestdb -e "quit" &gt; /dev/null 2&amp;&gt;1</div></pre></td></tr></table></figure><p>在抓包信息中显示,找不到db 2 这个库. -e “quit” 会导致这个错误,也不知怎么回事.</p><p>最后想到一个办法,直接使用C++写客户端,虽然麻烦一点,但是可以知道出问题的连接的端口号,这样就可以精确查找这个端口号的所有收发包了.同时也可以精确的计算一个连接创建的耗时而不是像脚本里面那样,计算了创建的耗时加上断开的耗时.</p><h1 id="使用C-编写测试客户端"><a href="#使用C-编写测试客户端" class="headerlink" title="使用C++编写测试客户端"></a>使用C++编写测试客户端</h1><p>以下代码使用了google test 框架 和 mysql c driver</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">100000</span>; ++i) &#123;</div><div class="line">  <span class="keyword">auto</span> now = TNOWMS;</div><div class="line">  <span class="keyword">auto</span> _pstMql = mysql_init(<span class="literal">NULL</span>);</div><div class="line">  <span class="keyword">auto</span> elapsed_mysql_init = TNOWMS - now;</div><div class="line">  <span class="keyword">auto</span> now1 = TNOWMS;</div><div class="line">  <span class="comment">//建立连接后, 自动调用设置字符集语句</span></div><div class="line">  <span class="keyword">if</span> (mysql_options(_pstMql, MYSQL_SET_CHARSET_NAME, <span class="string">"utf8"</span>)) &#123;</div><div class="line">    <span class="keyword">throw</span> TC_Mysql_Exception(<span class="built_in">string</span>(<span class="string">"TC_Mysql::connect: mysql_options MYSQL_SET_CHARSET_NAME "</span>) + <span class="string">"utf8"</span> + <span class="string">":"</span> + <span class="built_in">string</span>(mysql_error(_pstMql)));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">auto</span> elapsed_options = TNOWMS - now1;</div><div class="line">  <span class="keyword">auto</span> now2 = TNOWMS;</div><div class="line">  <span class="keyword">if</span> (mysql_real_connect(_pstMql, <span class="string">"192.168.0.11"</span>, <span class="string">"test"</span>, <span class="string">"123456"</span>, <span class="literal">NULL</span>, (<span class="keyword">int</span>)<span class="number">3306</span>, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> TC_Mysql_Exception(<span class="string">"[TC_Mysql::connect]: mysql_real_connect: "</span> + <span class="built_in">string</span>(mysql_error(_pstMql)));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">auto</span> elapsed_conn = TNOWMS - now2;</div><div class="line">  <span class="keyword">auto</span> elapsed = TNOWMS - now;</div><div class="line">  <span class="keyword">if</span> (elapsed &gt; <span class="number">500</span>) &#123;  <span class="comment">//如果创建连接耗时500以上</span></div><div class="line">    <span class="keyword">auto</span> localIpPort = getIPHostBySocketFD(_pstMql-&gt;net.fd, <span class="literal">true</span>);  <span class="comment">//获取当前连接的local port和peer port</span></div><div class="line">    <span class="keyword">auto</span> peerIpPort = getIPHostBySocketFD(_pstMql-&gt;net.fd, <span class="literal">false</span>);</div><div class="line">    DEBUGLOG &lt;&lt; <span class="string">"local|"</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(localIpPort) &lt;&lt; <span class="string">"|"</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(localIpPort) &lt;&lt; <span class="string">"|peer|"</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(peerIpPort) &lt;&lt; <span class="string">"|"</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(peerIpPort) &lt;&lt; <span class="string">"|mysql_init|"</span> &lt;&lt; elapsed_mysql_init &lt;&lt; <span class="string">"|elapsed_options|"</span> &lt;&lt; elapsed_options &lt;&lt; <span class="string">"|elapsed_connect|"</span> &lt;&lt; elapsed_conn &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">  ASSERT_LT(elapsed, <span class="number">500</span>);</div><div class="line">  mysql_close(_pstMql);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>编译执行之后, 捕获到了一个端口号为 58818 连接耗时过高</p><img src="/2017/09/28/使用tcpdump抓包并通过wireshark图形化工具来分析网络问题/wireshark.png" alt="[wireshark]" title="[wireshark]"><p>通过以上截图中的时间可以看到, 主要是 Mysql协议的登录请求导致耗时过高.</p><p>接下来,就可以去查查Mysql登录的回包为啥会这么慢了.抓包这部分的工作就算是完成了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h1&gt;&lt;p&gt;最近后台告警信息比较多, 大概看了一下, 发现一些很正常的请求偶尔会有几百毫秒甚至一两秒的耗时. 分析了一下代码, 应该不是
      
    
    </summary>
    
    
      <category term="抓包" scheme="http://lida.site/tags/%E6%8A%93%E5%8C%85/"/>
    
      <category term="tcpdump" scheme="http://lida.site/tags/tcpdump/"/>
    
      <category term="wireshark" scheme="http://lida.site/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title>解决libmysqlclient在多线程环境下初始化会有几率crash的问题</title>
    <link href="http://lida.site/2017/08/31/how-to-fix-libmysqlclient-init-crash-in-multithreading-environment/"/>
    <id>http://lida.site/2017/08/31/how-to-fix-libmysqlclient-init-crash-in-multithreading-environment/</id>
    <published>2017-08-31T07:38:41.000Z</published>
    <updated>2017-08-31T08:03:03.473Z</updated>
    
    <content type="html"><![CDATA[<p>这个问题在<a href="/2017/08/28/fix-mysql-c-connector-driver-crash-on-mysql-options-with-multithreading/" title="之前的一篇文章">之前的一篇文章</a>中提到过,通过更换libmysqlclient的版本暂时规避了这个问题,但是后面使用过程中发现,其实还是不对的,启动时mysql_init有几率会返回一个空指针,后面的逻辑就走不下去了.所以怀疑这个问题其实和库的版本无关, 换了个库版本只是让问题的表现形式不同了而已.</p><p>上mysql官网继续查阅文档,发现一篇文档如下:</p><blockquote><p><a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-init.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.7/en/mysql-init.html</a><br>In a nonmulti-threaded environment, mysql_init() invokes mysql_library_init() automatically as necessary. However, mysql_library_init() is not thread-safe in a multi-threaded environment, and thus neither is mysql_init(). Before calling mysql_init(), either call mysql_library_init() prior to spawning any threads, or use a mutex to protect the mysql_library_init() call. This should be done prior to any other client library call.</p></blockquote><p>大概意思是 mysql_init 会检查 mysql_library_init这个函数是否有调用过,如果没调用过就会去调用一次, 而mysql_library_init这个函数不是线程安全的,所以导致mysql_init 也不是线程安全的, 所以需要在调用libmysqlclient 库里面的任何一个函数之前调用mysql_library_init, 用面向对象的思想来理解,就类似于单例模式的主动初始化.</p><p>为了验证问题是否被解决,我写了如下测试代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dbname = <span class="string">"testdb"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> ip = <span class="string">"192.168.0.1"</span>;</div><div class="line"><span class="keyword">int</span> port = <span class="number">3306</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> username = <span class="string">"testuser1"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> password = <span class="string">"asdfgh"</span>;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::thread&gt;&gt; threads;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i != <span class="number">100</span>; ++i) &#123;</div><div class="line">  <span class="keyword">auto</span> pThread = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::thread&gt;([&amp;]()&#123;</div><div class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TC_Mysql&gt; pMysqlConn(<span class="keyword">new</span> TC_Mysql(ip, username, password, dbname, <span class="string">"utf8"</span>, port));</div><div class="line">      pMysqlConn-&gt;connect();</div><div class="line">      DEBUGLOG &lt;&lt; <span class="string">"mysql connected"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;);</div><div class="line">  threads.emplace_back(pThread);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pT : threads) &#123;</div><div class="line">  pT-&gt;join();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码开启了100个线程,每个线程内只做一件事,就是创建一个mysql连接并连接到mysql服务器.</p><p>毫无悬念的,直接执行会导致crash.</p><p>现在,把他修改一下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dbname = <span class="string">"testdb"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> ip = <span class="string">"192.168.0.1"</span>;</div><div class="line"><span class="keyword">int</span> port = <span class="number">3306</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> username = <span class="string">"testuser1"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> password = <span class="string">"asdfgh"</span>;</div><div class="line">mysql_library_init(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);  <span class="comment">//这里增加了一行libmysqlclient库初始化代码</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::thread&gt;&gt; threads;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i != <span class="number">100</span>; ++i) &#123;</div><div class="line">  <span class="keyword">auto</span> pThread = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::thread&gt;([&amp;]()&#123;</div><div class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TC_Mysql&gt; pMysqlConn(<span class="keyword">new</span> TC_Mysql(ip, username, password, dbname, <span class="string">"utf8"</span>, port));</div><div class="line">      pMysqlConn-&gt;connect();</div><div class="line">      DEBUGLOG &lt;&lt; <span class="string">"mysql connected"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;);</div><div class="line">  threads.emplace_back(pThread);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pT : threads) &#123;</div><div class="line">  pT-&gt;join();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在创建连接之前调用  mysql_library_init 函数,编译运行后发现可以成功创建连接,程序不会crash.</p><p>至此这个问题算是最终解决了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个问题在&lt;a href=&quot;/2017/08/28/fix-mysql-c-connector-driver-crash-on-mysql-options-with-multithreading/&quot; title=&quot;之前的一篇文章&quot;&gt;之前的一篇文章&lt;/a&gt;中提到过,通过更换l
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://lida.site/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="ubuntu" scheme="http://lida.site/tags/ubuntu/"/>
    
      <category term="mysql" scheme="http://lida.site/tags/mysql/"/>
    
      <category term="crash" scheme="http://lida.site/tags/crash/"/>
    
      <category term="libmysqlclient" scheme="http://lida.site/tags/libmysqlclient/"/>
    
  </entry>
  
  <entry>
    <title>找到某个命令依赖的软件包名称</title>
    <link href="http://lida.site/2017/08/28/how-to-find-a-command-depends-of/"/>
    <id>http://lida.site/2017/08/28/how-to-find-a-command-depends-of/</id>
    <published>2017-08-28T09:39:20.000Z</published>
    <updated>2017-08-28T09:41:33.541Z</updated>
    
    <content type="html"><![CDATA[<p>前两天需要使用mkpasswd这个命令用来加密密码,发现ubuntu16.04似乎没有自带这个命令, 直接apt-get install mkpasswd显示找不到任何软件包.就在想如果有个命令可以反向查找软件包名称就好了,google了一下果然有, 在这里记录一下,以免遗忘.</p><p>Ubuntu:</p><blockquote><p>$apt-get install apt-file<br>$apt-file update<br>$apt-file search<br>$apt-file search mkpasswd</p></blockquote><p>CentOS:</p><blockquote><p>yum whatprovides commandName</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两天需要使用mkpasswd这个命令用来加密密码,发现ubuntu16.04似乎没有自带这个命令, 直接apt-get install mkpasswd显示找不到任何软件包.就在想如果有个命令可以反向查找软件包名称就好了,google了一下果然有, 在这里记录一下,以免遗
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="http://lida.site/tags/ubuntu/"/>
    
      <category term="linux" scheme="http://lida.site/tags/linux/"/>
    
      <category term="apt-get" scheme="http://lida.site/tags/apt-get/"/>
    
  </entry>
  
  <entry>
    <title>解决libmysqlclient 在多线程下调用mysql_options 函数出现Segmentation fault的问题</title>
    <link href="http://lida.site/2017/08/28/fix-mysql-c-connector-driver-crash-on-mysql-options-with-multithreading/"/>
    <id>http://lida.site/2017/08/28/fix-mysql-c-connector-driver-crash-on-mysql-options-with-multithreading/</id>
    <published>2017-08-28T07:15:53.000Z</published>
    <updated>2017-08-31T08:04:35.703Z</updated>
    
    <content type="html"><![CDATA[<p>一个服务,临近发布时突然发现在启动时会core dump, 通过调低线程数可以解决, 仔细调试后发现程序在调用mysql_options时触发了Segmentation fault.<br>服务有多个线程,每个线程一个mysql 连接, 在每个线程调用所有mysql_* 函数之前先调用了mysql_init.</p><p>查阅了官方文档: <a href="https://dev.mysql.com/doc/refman/5.7/en/c-api-threaded-clients.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.7/en/c-api-threaded-clients.html</a> 按照这个多线程编程指引,我的程序并没有问题.</p><p>查询自己的mysql库 的版本号,是 ubuntu16.04 软件库默认的版本:</p><blockquote><p>$ dpkg -l | grep mysqlclient<br>ii  libmysqlclient-dev                        5.7.19-0ubuntu0.16.04.1   amd64                     MySQL database development files<br>ii  libmysqlclient20:amd64                    5.7.19-0ubuntu0.16.04.1   amd64                     MySQL database client library</p></blockquote><p>怀疑是不是这个版本的库有bug, 上google查了一下没找到什么资料.于是自己动手,丰衣足食,上mysql官网下载了一个最新的c_connector 替换掉之前的库,开200个线程测试,一切ok.</p><p>下载连接:</p><blockquote><p><a href="https://cdn.mysql.com//Downloads/Connector-C/mysql-connector-c-6.1.11-linux-glibc2.12-x86_64.tar.gz" target="_blank" rel="external">https://cdn.mysql.com//Downloads/Connector-C/mysql-connector-c-6.1.11-linux-glibc2.12-x86_64.tar.gz</a></p></blockquote><p>没想到作为LTS版本的ubuntu官方软件库提供的库会有这么严重的bug, 看样子以后所有的库要尽量用官方发布的版本.</p><p>2017-08-31 增加:<br>后面发现通过更换libmysqlclient版本并不能解决问题,只是让问题的表现形式变得不同了, 彻底解决这个问题请看<a href="/2017/08/31/how-to-fix-libmysqlclient-init-crash-in-multithreading-environment/" title="这里">这里</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个服务,临近发布时突然发现在启动时会core dump, 通过调低线程数可以解决, 仔细调试后发现程序在调用mysql_options时触发了Segmentation fault.&lt;br&gt;服务有多个线程,每个线程一个mysql 连接, 在每个线程调用所有mysql_* 函
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://lida.site/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="ubuntu" scheme="http://lida.site/tags/ubuntu/"/>
    
      <category term="mysql" scheme="http://lida.site/tags/mysql/"/>
    
      <category term="crash" scheme="http://lida.site/tags/crash/"/>
    
      <category term="libmysqlclient" scheme="http://lida.site/tags/libmysqlclient/"/>
    
  </entry>
  
  <entry>
    <title>在ubuntu上安装source-code-pro字体</title>
    <link href="http://lida.site/2017/08/25/how-to-install-adobe-source-code-pro-in-ubuntu/"/>
    <id>http://lida.site/2017/08/25/how-to-install-adobe-source-code-pro-in-ubuntu/</id>
    <published>2017-08-25T01:36:40.000Z</published>
    <updated>2017-08-28T07:27:43.478Z</updated>
    
    <content type="html"><![CDATA[<p>只需要两行命令,记录一下</p><blockquote><p>sudo git clone <a href="https://github.com/adobe-fonts/source-code-pro.git" target="_blank" rel="external">https://github.com/adobe-fonts/source-code-pro.git</a> /usr/share/fonts/opentype/scp<br>cd /usr/share/fonts/opentype/scp<br>sudo git checkout release   //很重要,直接使用master编译字体后可能会导致乱码<br>sudo fc-cache -f -v</p></blockquote><p>如果 /usr/share/fonts/opentype/ 文件夹不存在,可以 sudo mkdir -p /usr/share/fonts/opentype/ 创建</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;只需要两行命令,记录一下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo git clone &lt;a href=&quot;https://github.com/adobe-fonts/source-code-pro.git&quot; target=&quot;_blank&quot; rel=&quot;externa
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://lida.site/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="字体" scheme="http://lida.site/tags/%E5%AD%97%E4%BD%93/"/>
    
      <category term="ubuntu" scheme="http://lida.site/tags/ubuntu/"/>
    
      <category term="linux" scheme="http://lida.site/tags/linux/"/>
    
      <category term="fc-cache" scheme="http://lida.site/tags/fc-cache/"/>
    
  </entry>
  
  <entry>
    <title>在emacs中跳转光标到之前所在位置的几个方法</title>
    <link href="http://lida.site/2017/08/22/how-to-jump-to-previous-position-in-emacs/"/>
    <id>http://lida.site/2017/08/22/how-to-jump-to-previous-position-in-emacs/</id>
    <published>2017-08-22T09:18:11.000Z</published>
    <updated>2017-08-25T03:30:48.874Z</updated>
    
    <content type="html"><![CDATA[<p>仔细找了一下,有几个命令可以提供类似的功能:</p><blockquote><p>pop-global-mark C-x C-SPC</p></blockquote><p>这个命令提供了全局跳转到光标之前所在位置的功能,实际上这里也会有一个光标位置的list, 我安装了helm插件,所以有命令helm-global-mark-ring可以查看当前保存了哪些位置,这些位置信息就是一个环形队列, 使用pop-global-mark 来pop这个队列的最后一个元素,然后跳转过去.<br>试用后发现这个命令只有在显式使用C+SPC 进行 mark 操作并且马上切换到其他buffer时才会记录之前的位置, 而且同一个buffer记录的位置如果不pop掉,那么下次在同一个buffer内mark 其他位置也不会被放到global-mark-ring里面<br>用法比较奇怪.因为buffer之间的切换本来就很简单,C-x C-b 可以很方便的浏览所有的buffer并切换，切换buffer之前mark一下有点累赘了,所以个人感觉还是下一个命令适用范围比较广.</p><blockquote><p>C-u C-SPC</p></blockquote><p>这个命令会记录你的每次移动之前的位置,随便翻页,或者慢速上下移动光标,都会被记录,但是仅限当前buffer. 很多场景下也够用了, 如果安装了helm插件，可以通过helm-all-mark-rings来观察记录的位置</p><blockquote><p>helm-all-mark-rings</p></blockquote><p>这个命令可以很方便的查看当前所有的mark,当按快捷键得到的结果不符合预期时,可以再通过这个命令找到正确的跳转地址.</p><p>通过这三个命令应该可以更方便的在各种文件中jump了。</p><p>ps: 如果helm出现了两个结果列表(例如helm-all-mark-rings),可以使用C-o和M-o来切换列表, 前者表示next, 后者表示previous.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;仔细找了一下,有几个命令可以提供类似的功能:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pop-global-mark C-x C-SPC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个命令提供了全局跳转到光标之前所在位置的功能,实际上这里也会有一个光标位置的list, 我安
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://lida.site/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="emacs" scheme="http://lida.site/tags/emacs/"/>
    
      <category term="编辑器" scheme="http://lida.site/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="ide" scheme="http://lida.site/tags/ide/"/>
    
  </entry>
  
  <entry>
    <title>开了一个新的博客，在这里记录一些想法</title>
    <link href="http://lida.site/2017/08/22/new_blog_new_thought/"/>
    <id>http://lida.site/2017/08/22/new_blog_new_thought/</id>
    <published>2017-08-21T16:26:59.000Z</published>
    <updated>2017-08-22T06:37:07.998Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现vim的键位其实也挺好用的，工作时在线上环境不方便安装emacs以及他的一大堆插件，这时候vim就派上用场啦，所以熟悉vim的键位还是很重要的。<br>为了让自己的记忆成本最低，我觉得一定要抽空转spacemacs，尝试过两三次，还是没办法习惯。<br>因为我使用emacs比较重要的一个原因是eshell，可以很方便的操作光标进行各种复制粘贴操作，spaceemacs似乎对eshell不太友好。<br>spaceemacs的键位绑定也看得云里雾里的，还弄出了一个layer概念，不知道要怎么弄。<br>其实，我只需要把现在prelude 这一套的键位照搬到spacemacs应该就可以用得比较舒服了。得找时间试试看。<br>还有我自己的一些emacs私有配置因为换工作换电脑也弄丢了，挺可惜的。</p><p>emacs 用了这么久，总体来说挺方便，就是有一点不爽，缺少了回到光标之前所在的位置这个功能，几年前还在用vs的时候，这个功能可是相当好用啊，后来转linux，用了emacs后，似乎就没有用过这个功能了，曾经找了一阵子也没找到提供光标历史位置跳转的插件。所以现在我要先预测我下一步要跳到很远的地方，比如我现在的文件总共有1000行，我现在在500行，需要跳转到当前文件的某个函数，在第10行，那么我就只能C+x r spc a，来保存当前光标位置为a，然后再M+g g 10 到第10行，看完这个函数后再 C+x r j a 跳回去。太不方便了。<br>如果有插件可以根据光标停留的秒数来记录光标的位置，一个快捷键就可以回到光标的上一个位置，另一个快捷键前进到光标的下一个位置，类似于undo，redo。这样就方便多了。<br>我相信这么一个成熟的需求肯定有插件，只是我一直没找到。</p><p>有时间我再去找找，找到再回来发博客。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近发现vim的键位其实也挺好用的，工作时在线上环境不方便安装emacs以及他的一大堆插件，这时候vim就派上用场啦，所以熟悉vim的键位还是很重要的。&lt;br&gt;为了让自己的记忆成本最低，我觉得一定要抽空转spacemacs，尝试过两三次，还是没办法习惯。&lt;br&gt;因为我使用e
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://lida.site/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="emacs" scheme="http://lida.site/tags/emacs/"/>
    
      <category term="编辑器" scheme="http://lida.site/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="ide" scheme="http://lida.site/tags/ide/"/>
    
      <category term="vim" scheme="http://lida.site/tags/vim/"/>
    
  </entry>
  
</feed>
